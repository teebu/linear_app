import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */
    DateTime: Date;
    /** The `JSON` scalar type represents JSON values */
    JSON: Record<string, unknown>;
    /** The `JSONObject` scalar type represents JSON values as a string */
    JSONObject: Record<string, unknown>;
    /** The `TimelessDateScalar` scalar type represents Date values without a timestamp. It expects strings in the format YYYY-MM-DD */
    TimelessDateScalar: Date;
};
/** An API key. Grants access to the user's resources. */
export declare type ApiKey = Node & {
    __typename?: "ApiKey";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The label of the API key. */
    label: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type ApiKeyConnection = {
    __typename?: "ApiKeyConnection";
    edges: Array<ApiKeyEdge>;
    nodes: Array<ApiKey>;
    pageInfo: PageInfo;
};
export declare type ApiKeyCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The API key value (format: /^[a-zA-Z0-9]{40}$/). */
    key: Scalars["String"];
    /** The label for the API key. */
    label: Scalars["String"];
};
export declare type ApiKeyEdge = {
    __typename?: "ApiKeyEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ApiKey;
};
export declare type ApiKeyPayload = {
    __typename?: "ApiKeyPayload";
    /** The API key that was created. */
    apiKey: ApiKey;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application. */
export declare type Application = {
    __typename?: "Application";
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
};
export declare type ArchivePayload = {
    __typename?: "ArchivePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Contains requested archived model objects. */
export declare type ArchiveResponse = {
    __typename?: "ArchiveResponse";
    /** A JSON serialized collection of model objects loaded from the archive */
    archive: Scalars["String"];
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /** The total number of entities in the archive. */
    totalCount: Scalars["Float"];
};
/** [Alpha] Issue attachment (e.g. support ticket, pull request). */
export declare type Attachment = Node & {
    __typename?: "Attachment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue this attachment belongs to. */
    issue: Issue;
    /** Custom metadata related to the attachment. */
    metadata: Scalars["JSONObject"];
    /** Information about the source which created the attachment. */
    source?: Maybe<Scalars["JSONObject"]>;
    /** Content for the subtitle line in the Linear attachment widget. */
    subtitle?: Maybe<Scalars["String"]>;
    /** Content for the title line in the Linear attachment widget. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Location of the attachment which is also used as an identifier. Attachment URLs are unique and calls to create a new attachment are idempotent with the URL. */
    url: Scalars["String"];
};
export declare type AttachmentConnection = {
    __typename?: "AttachmentConnection";
    edges: Array<AttachmentEdge>;
    nodes: Array<Attachment>;
    pageInfo: PageInfo;
};
export declare type AttachmentCreateInput = {
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource?: Maybe<Scalars["Boolean"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the attachment with. */
    issueId: Scalars["String"];
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
    /** Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead. */
    url: Scalars["String"];
};
export declare type AttachmentEdge = {
    __typename?: "AttachmentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Attachment;
};
export declare type AttachmentPayload = {
    __typename?: "AttachmentPayload";
    /** The issue attachment that was created. */
    attachment: Attachment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type AttachmentUpdateInput = {
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
};
export declare type AuthResolverResponse = {
    __typename?: "AuthResolverResponse";
    /** Should the signup flow allow access for the domain. */
    allowDomainAccess?: Maybe<Scalars["Boolean"]>;
    /** Organizations this account has access to, but is not yet a member. */
    availableOrganizations?: Maybe<Array<Organization>>;
    /** Email for the authenticated account. */
    email?: Maybe<Scalars["String"]>;
    /** User account ID. */
    id: Scalars["String"];
    /** JWT token for authentication of the account. */
    token?: Maybe<Scalars["String"]>;
    /** Users belonging to this account. */
    users: Array<User>;
};
/** Public information of the OAuth application, plus the authorized scopes for a given user. */
export declare type AuthorizedApplication = {
    __typename?: "AuthorizedApplication";
    /** OAuth application's ID. */
    appId: Scalars["String"];
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
    /** Scopes that are authorized for this application for a given user. */
    scope: Array<Scalars["String"]>;
};
export declare type BillingDetailsPayload = {
    __typename?: "BillingDetailsPayload";
    /** The customer's email address the invoices are sent to. */
    email?: Maybe<Scalars["String"]>;
    /** List of invoices, if any. */
    invoices: Array<Invoice>;
    /** The payment method. */
    paymentMethod?: Maybe<Card>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type BillingEmailPayload = {
    __typename?: "BillingEmailPayload";
    /** The customer's email address the invoices are sent to. */
    email?: Maybe<Scalars["String"]>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type BillingEmailUpdateInput = {
    /** The email address to which to send invoices. */
    email: Scalars["String"];
};
export declare type Card = {
    __typename?: "Card";
    /** The brand of the card, e.g. Visa. */
    brand: Scalars["String"];
    /** The last four digits used to identify the card. */
    last4: Scalars["String"];
};
export declare type CollaborationDocumentUpdateInput = {
    /** Client identifier. */
    clientId: Scalars["String"];
    /** Document identifier. */
    issueId: Scalars["String"];
    /** New document steps from the client. */
    steps: Array<Scalars["JSON"]>;
    /** Client's document version number. */
    version: Scalars["Int"];
};
export declare type CollaborationDocumentUpdatePayload = {
    __typename?: "CollaborationDocumentUpdatePayload";
    /** Document steps the client has not seen yet and need to rebase it's local steps on. */
    steps?: Maybe<StepsResponse>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A comment associated with an issue. */
export declare type Comment = Node & {
    __typename?: "Comment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment content in markdown format. */
    body: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The time user edited the comment. */
    editedAt?: Maybe<Scalars["DateTime"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the comment is associated with. */
    issue: Issue;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Comment's URL. */
    url: Scalars["String"];
    /** The user who wrote the comment. */
    user: User;
};
export declare type CommentConnection = {
    __typename?: "CommentConnection";
    edges: Array<CommentEdge>;
    nodes: Array<Comment>;
    pageInfo: PageInfo;
};
export declare type CommentCreateInput = {
    /** The comment content in markdown format. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the comment with. */
    issueId: Scalars["String"];
};
export declare type CommentEdge = {
    __typename?: "CommentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Comment;
};
export declare type CommentPayload = {
    __typename?: "CommentPayload";
    /** The comment that was created or updated. */
    comment: Comment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CommentUpdateInput = {
    /** The comment content. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
};
/** GitHub's commit data */
export declare type CommitPayload = {
    __typename?: "CommitPayload";
    added: Array<Scalars["String"]>;
    id: Scalars["String"];
    message: Scalars["String"];
    modified: Array<Scalars["String"]>;
    removed: Array<Scalars["String"]>;
    timestamp: Scalars["String"];
    url: Scalars["String"];
};
export declare type ContactCreateInput = {
    /** User's browser information. */
    browser?: Maybe<Scalars["String"]>;
    /** User's device information. */
    device?: Maybe<Scalars["String"]>;
    /** How disappointed the user would be if they could no longer use Linear. */
    disappointmentRating?: Maybe<Scalars["Int"]>;
    /** The message the user sent. */
    message: Scalars["String"];
    /** User's operating system. */
    operatingSystem?: Maybe<Scalars["String"]>;
    /** The type of support contact. */
    type: Scalars["String"];
};
export declare type ContactPayload = {
    __typename?: "ContactPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CreateCsvExportReportPayload = {
    __typename?: "CreateCsvExportReportPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CreateOrJoinOrganizationResponse = {
    __typename?: "CreateOrJoinOrganizationResponse";
    organization: Organization;
    user: User;
};
export declare type CreateOrganizationInput = {
    /** Whether the organization should allow email domain access. */
    domainAccess?: Maybe<Scalars["Boolean"]>;
    /** The name of the organization. */
    name: Scalars["String"];
    /** The timezone of the organization, passed in by client. */
    timezone?: Maybe<Scalars["String"]>;
    /** The URL key of the organization. */
    urlKey: Scalars["String"];
    /** JSON serialized UTM parameters associated with the creation of the workspace. */
    utm?: Maybe<Scalars["String"]>;
};
/** A custom view that has been saved by a user. */
export declare type CustomView = Node & {
    __typename?: "CustomView";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the custom view. */
    creator: User;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filters applied to issues in the custom view. */
    filters: Scalars["JSONObject"];
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the custom view. */
    name: Scalars["String"];
    /** The organization of the custom view. */
    organization: Organization;
    /** Whether the custom view is shared with everyone in the organization. */
    shared: Scalars["Boolean"];
    /** The team associated with the custom view. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type CustomViewConnection = {
    __typename?: "CustomViewConnection";
    edges: Array<CustomViewEdge>;
    nodes: Array<CustomView>;
    pageInfo: PageInfo;
};
export declare type CustomViewCreateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name: Scalars["String"];
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type CustomViewEdge = {
    __typename?: "CustomViewEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: CustomView;
};
export declare type CustomViewPayload = {
    __typename?: "CustomViewPayload";
    /** The custom view that was created or updated. */
    customView: CustomView;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CustomViewUpdateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type Cycle = Node & {
    __typename?: "Cycle";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the cycle after each day. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each day. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The end time of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The total number of issues in the cycle after each day. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the cycle. */
    issues: IssueConnection;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The number of the cycle. */
    number: Scalars["Float"];
    /** The total number of estimation points after each day. */
    scopeHistory: Array<Scalars["Float"]>;
    /** The start time of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team that the cycle is associated with. */
    team: Team;
    /** Issues that weren't completed when the cycle was closed. */
    uncompletedIssuesUponClose: IssueConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleUncompletedIssuesUponCloseArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type CycleConnection = {
    __typename?: "CycleConnection";
    edges: Array<CycleEdge>;
    nodes: Array<Cycle>;
    pageInfo: PageInfo;
};
export declare type CycleCreateInput = {
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The end date of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team to associate the cycle with. */
    teamId: Scalars["String"];
};
export declare type CycleEdge = {
    __typename?: "CycleEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Cycle;
};
export declare type CyclePayload = {
    __typename?: "CyclePayload";
    /** The Cycle that was created or updated. */
    cycle?: Maybe<Cycle>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CycleUpdateInput = {
    /** The end date of the cycle. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The end date of the cycle. */
    endsAt?: Maybe<Scalars["DateTime"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt?: Maybe<Scalars["DateTime"]>;
};
export declare type DebugPayload = {
    __typename?: "DebugPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type DeleteOrganizationInput = {
    /** The deletion code to confirm operation. */
    deletionCode: Scalars["String"];
};
/** Collaborative editing steps for documents. */
export declare type DocumentStep = Node & {
    __typename?: "DocumentStep";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Connected client ID. */
    clientId: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Step data. */
    step: Scalars["JSON"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Step version. */
    version: Scalars["Float"];
};
export declare type EmailUnsubscribeInput = {
    /** The user's email validation token. */
    token: Scalars["String"];
    /** Email type to unsubscribed from. */
    type: Scalars["String"];
    /** The identifier of the user. */
    userId: Scalars["String"];
};
export declare type EmailUnsubscribePayload = {
    __typename?: "EmailUnsubscribePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EmailUserAccountAuthChallengeInput = {
    /** The email for which to generate the magic login code. */
    email: Scalars["String"];
    /** Whether the login was requested from the desktop app. */
    isDesktop?: Maybe<Scalars["Boolean"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
};
export declare type EmailUserAccountAuthChallengeResponse = {
    __typename?: "EmailUserAccountAuthChallengeResponse";
    /** Supported challenge for this user account. Can be either verificationCode or password. */
    authType: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A custom emoji. */
export declare type Emoji = Node & {
    __typename?: "Emoji";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the emoji. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The emoji's name. */
    name: Scalars["String"];
    /** The organization that the emoji belongs to. */
    organization: Organization;
    /** The source of the emoji. */
    source: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The emoji image URL. */
    url: Scalars["String"];
};
export declare type EmojiConnection = {
    __typename?: "EmojiConnection";
    edges: Array<EmojiEdge>;
    nodes: Array<Emoji>;
    pageInfo: PageInfo;
};
export declare type EmojiCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom emoji. */
    name: Scalars["String"];
    /** The URL for the emoji. */
    url: Scalars["String"];
};
export declare type EmojiEdge = {
    __typename?: "EmojiEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Emoji;
};
export declare type EmojiPayload = {
    __typename?: "EmojiPayload";
    /** The emoji that was created. */
    emoji: Emoji;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EventCreateInput = {
    /** The category of the event to create. */
    category: Scalars["String"];
    /** Additional data of the event, encoded as JSON. */
    data?: Maybe<Scalars["JSON"]>;
    /** The subject of the event. */
    subject: Scalars["String"];
    /** The target identifier of the event. */
    targetId?: Maybe<Scalars["String"]>;
    /** The value of the event. */
    value?: Maybe<Scalars["Float"]>;
};
export declare type EventPayload = {
    __typename?: "EventPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** User favorites presented in the sidebar. */
export declare type Favorite = Node & {
    __typename?: "Favorite";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Favorited cycle. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Favorited issue. */
    issue?: Maybe<Issue>;
    /** Favorited issue label. */
    label?: Maybe<IssueLabel>;
    /** Favorited project. */
    project?: Maybe<Project>;
    /** Favorited project team. */
    projectTeam?: Maybe<Project>;
    /** The order of the item in the favorites list. */
    sortOrder: Scalars["Float"];
    /** The type of the favorite. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The owner of the favorite. */
    user: User;
};
export declare type FavoriteConnection = {
    __typename?: "FavoriteConnection";
    edges: Array<FavoriteEdge>;
    nodes: Array<Favorite>;
    pageInfo: PageInfo;
};
export declare type FavoriteCreateInput = {
    /** The identifier of the custom view to favorite. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The identifier of the cycle to favorite. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue to favorite. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the label to favorite. */
    labelId?: Maybe<Scalars["String"]>;
    /** The identifier of the project to favorite. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the project team to favorite. */
    projectTeamId?: Maybe<Scalars["String"]>;
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type FavoriteEdge = {
    __typename?: "FavoriteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Favorite;
};
export declare type FavoritePayload = {
    __typename?: "FavoritePayload";
    /** The object that was added as a favorite. */
    favorite: Favorite;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type FavoriteUpdateInput = {
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type FeedbackCreateInput = {
    /** How disappointed the user would be if he/she could no longer use Linear. */
    disappointmentRating: Scalars["Float"];
    /** The feedback the user sent. */
    feedback: Scalars["String"];
};
export declare type FeedbackPayload = {
    __typename?: "FeedbackPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Object representing Figma preview information. */
export declare type FigmaEmbed = {
    __typename?: "FigmaEmbed";
    /** Date when the file was updated at the time of embedding. */
    lastModified: Scalars["DateTime"];
    /** Figma file name. */
    name: Scalars["String"];
    /** Node name. */
    nodeName?: Maybe<Scalars["String"]>;
    /** Figma screenshot URL. */
    url?: Maybe<Scalars["String"]>;
};
export declare type FigmaEmbedPayload = {
    __typename?: "FigmaEmbedPayload";
    /** Figma embed information. */
    figmaEmbed?: Maybe<FigmaEmbed>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A recorded entry of a file uploaded by a user. */
export declare type FileUpload = {
    __typename?: "FileUpload";
    /** The asset URL this file is available at. */
    assetUrl?: Maybe<Scalars["String"]>;
    /** The MIME type of the uploaded file. */
    contentType?: Maybe<Scalars["String"]>;
    /** The user who uploaded the file. */
    creator?: Maybe<User>;
    /** The name of the uploaded file. */
    filename?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Additional metadata of the file. */
    metaData: Scalars["JSON"];
    /** The organization the upload belongs to. */
    organization: Organization;
    /** Size of the uploaded file in bytes. */
    size: Scalars["Float"];
};
/** Relevant information for the GitHub organization. */
export declare type GithubOrg = {
    __typename?: "GithubOrg";
    /** GitHub org's id. */
    id: Scalars["String"];
    /** The login for the GitHub org. */
    login: Scalars["String"];
    /** The name of the GitHub org. */
    name: Scalars["String"];
    /** Repositories that the org owns. */
    repositories: Array<GithubRepo>;
};
/** Relevant information for the GitHub repository. */
export declare type GithubRepo = {
    __typename?: "GithubRepo";
    /** The id of the GitHub repository. */
    id: Scalars["String"];
    /** The name of the GitHub repository. */
    name: Scalars["String"];
};
/** Google Sheets specific settings. */
export declare type GoogleSheetsSettings = {
    __typename?: "GoogleSheetsSettings";
    sheetId: Scalars["Float"];
    spreadsheetId: Scalars["String"];
    spreadsheetUrl: Scalars["String"];
    updatedIssuesAt: Scalars["DateTime"];
};
export declare type GoogleUserAccountAuthInput = {
    /** Code returned from Google's OAuth flow. */
    code: Scalars["String"];
    /** The URI to redirect the user to. */
    redirectUri?: Maybe<Scalars["String"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
};
export declare type ImageUploadFromUrlPayload = {
    __typename?: "ImageUploadFromUrlPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The URL containing the image. */
    url?: Maybe<Scalars["String"]>;
};
/** An integration with an external service. */
export declare type Integration = Node & {
    __typename?: "Integration";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user that added the integration. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The organization that the integration is associated with. */
    organization: Organization;
    /** The integration's type. */
    service: Scalars["String"];
    /** The team that the integration is associated with. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationConnection = {
    __typename?: "IntegrationConnection";
    edges: Array<IntegrationEdge>;
    nodes: Array<Integration>;
    pageInfo: PageInfo;
};
export declare type IntegrationEdge = {
    __typename?: "IntegrationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Integration;
};
export declare type IntegrationPayload = {
    __typename?: "IntegrationPayload";
    /** The integration that was created or updated. */
    integration?: Maybe<Integration>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** An integration resource created by an external service. */
export declare type IntegrationResource = Node & {
    __typename?: "IntegrationResource";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Detailed information about the external resource. */
    data: IntegrationResourceData;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The integration that the resource is associated with. */
    integration: Integration;
    /** The issue that the resource is associated with. */
    issue: Issue;
    /** Pull request information for GitHub pull requests and GitLab merge requests. */
    pullRequest: PullRequestPayload;
    /** The external service resource ID. */
    resourceId: Scalars["String"];
    /** The integration's type. */
    resourceType: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationResourceConnection = {
    __typename?: "IntegrationResourceConnection";
    edges: Array<IntegrationResourceEdge>;
    nodes: Array<IntegrationResource>;
    pageInfo: PageInfo;
};
/** Integration resource's payload */
export declare type IntegrationResourceData = {
    __typename?: "IntegrationResourceData";
    /** The payload for an IntegrationResource of type 'githubCommit' */
    githubCommit?: Maybe<CommitPayload>;
    /** The payload for an IntegrationResource of type 'githubPullRequest' */
    githubPullRequest?: Maybe<PullRequestPayload>;
    /** The payload for an IntegrationResource of type 'gitlabMergeRequest' */
    gitlabMergeRequest?: Maybe<PullRequestPayload>;
    /** The payload for an IntegrationResource of type 'sentryIssue' */
    sentryIssue?: Maybe<SentryIssuePayload>;
};
export declare type IntegrationResourceEdge = {
    __typename?: "IntegrationResourceEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IntegrationResource;
};
/** The integration resource's settings */
export declare type IntegrationSettings = {
    __typename?: "IntegrationSettings";
    googleSheets?: Maybe<GoogleSheetsSettings>;
    sentry?: Maybe<SentrySettings>;
    slackPost?: Maybe<SlackPostSettings>;
    slackProjectPost?: Maybe<SlackPostSettings>;
    zendesk?: Maybe<ZendeskSettings>;
};
export declare type InviteData = {
    __typename?: "InviteData";
    /** Avatar URLs for the invitees. */
    avatarURLs: Array<Scalars["String"]>;
    /** The name of the inviter. */
    inviterName: Scalars["String"];
    /** The domain of the organization the users were invited to. */
    organizationDomain: Scalars["String"];
    /** The logo of the organization the users were invited to. */
    organizationLogoUrl?: Maybe<Scalars["String"]>;
    /** The name of the organization the users were invited to. */
    organizationName: Scalars["String"];
    /** Team identifiers for the invitees. */
    teamIds: Array<Scalars["String"]>;
    /** Team names for the invitees. */
    teamNames: Array<Scalars["String"]>;
    /** The user count of the organization. */
    userCount: Scalars["Float"];
};
export declare type InvitePagePayload = {
    __typename?: "InvitePagePayload";
    /** Invite data. */
    inviteData?: Maybe<InviteData>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type Invoice = {
    __typename?: "Invoice";
    /** The creation date of the invoice. */
    created: Scalars["TimelessDateScalar"];
    /** The due date of the invoice. */
    dueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The status of the invoice. */
    status: Scalars["String"];
    /** The invoice total, in cents. */
    total: Scalars["Float"];
    /** The URL at which the invoice can be viewed or paid. */
    url?: Maybe<Scalars["String"]>;
};
/** An issue. */
export declare type Issue = Node & {
    __typename?: "Issue";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The user to whom the issue is assigned to. */
    assignee?: Maybe<User>;
    /** Attachments associated with the issue. */
    attachments: AttachmentConnection;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Maybe<Scalars["DateTime"]>;
    /** The order of the item in its column on the board. */
    boardOrder: Scalars["Float"];
    /** Suggested branch name for the issue. */
    branchName: Scalars["String"];
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the issue. */
    children: IssueConnection;
    /** Comments associated with the issue. */
    comments: CommentConnection;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the issue. */
    creator?: Maybe<User>;
    /** The cycle that the issue is associated with. */
    cycle?: Maybe<Cycle>;
    /** The issue's description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The estimate of the complexity of the issue.. */
    estimate?: Maybe<Scalars["Float"]>;
    /** History entries associated with the issue. */
    history: IssueHistoryConnection;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: Scalars["String"];
    /** Integration resources for this issue. */
    integrationResources: IntegrationResourceConnection;
    /** Inverse relations associated with this issue. */
    inverseRelations: IssueRelationConnection;
    /** Labels associated with this issue. */
    labels: IssueLabelConnection;
    /** The issue's unique number. */
    number: Scalars["Float"];
    /** The parent of the issue. */
    parent?: Maybe<Issue>;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: Array<Scalars["String"]>;
    /** The priority of the issue. */
    priority: Scalars["Float"];
    /** Label for the priority. */
    priorityLabel: Scalars["String"];
    /** The project that the issue is associated with. */
    project?: Maybe<Project>;
    /** Relations associated with this issue. */
    relations: IssueRelationConnection;
    /** The time at which the issue was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The workflow state that the issue is associated with. */
    state: WorkflowState;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** Users who are subscribed to the issue. */
    subscribers: UserConnection;
    /** The team that the issue is associated with. */
    team: Team;
    /** The issue's title. */
    title: Scalars["String"];
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Issue URL. */
    url: Scalars["String"];
};
/** An issue. */
export declare type IssueAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueHistoryArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueIntegrationResourcesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueInverseRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueSubscribersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueConnection = {
    __typename?: "IssueConnection";
    edges: Array<IssueEdge>;
    nodes: Array<Issue>;
    pageInfo: PageInfo;
};
export declare type IssueCreateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId: Scalars["String"];
    /** The title of the issue. */
    title: Scalars["String"];
};
export declare type IssueEdge = {
    __typename?: "IssueEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Issue;
};
/** A record of changes to an issue. */
export declare type IssueHistory = Node & {
    __typename?: "IssueHistory";
    /** The user who made these changes. If null, possibly means that the change made by an integration. */
    actor?: Maybe<User>;
    /** ID's of labels that were added. */
    addedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** Whether the issue was archived or un-archived. */
    archived?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    autoArchived?: Maybe<Scalars["Boolean"]>;
    autoClosed?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user from whom the issue was re-assigned from. */
    fromAssignee?: Maybe<User>;
    /** The previous cycle of the issue. */
    fromCycle?: Maybe<Cycle>;
    /** What the due date was changed from */
    fromDueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** What the estimate was changed from. */
    fromEstimate?: Maybe<Scalars["Float"]>;
    /** The previous parent of the issue. */
    fromParent?: Maybe<Issue>;
    /** What the priority was changed from. */
    fromPriority?: Maybe<Scalars["Float"]>;
    /** The previous project of the issue. */
    fromProject?: Maybe<Project>;
    /** The previous workflow state of the issue. */
    fromState?: Maybe<WorkflowState>;
    /** The team from which the issue was moved from. */
    fromTeam?: Maybe<Team>;
    /** What the title was changed from. */
    fromTitle?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that was changed. */
    issue: Issue;
    /** Changed issue relationships. */
    relationChanges?: Maybe<Scalars["String"]>;
    /** ID's of labels that were removed. */
    removedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** Information about the integration or application which created this history entry. */
    source?: Maybe<Scalars["JSONObject"]>;
    /** The user to whom the issue was assigned to. */
    toAssignee?: Maybe<User>;
    /** The new cycle of the issue. */
    toCycle?: Maybe<Cycle>;
    /** What the due date was changed to */
    toDueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** What the estimate was changed to. */
    toEstimate?: Maybe<Scalars["Float"]>;
    /** The new parent of the issue. */
    toParent?: Maybe<Issue>;
    /** What the priority was changed to. */
    toPriority?: Maybe<Scalars["Float"]>;
    /** The new project of the issue. */
    toProject?: Maybe<Project>;
    /** The new workflow state of the issue. */
    toState?: Maybe<WorkflowState>;
    /** The team to which the issue was moved to. */
    toTeam?: Maybe<Team>;
    /** What the title was changed to. */
    toTitle?: Maybe<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Whether the issue's description was updated. */
    updatedDescription?: Maybe<Scalars["Boolean"]>;
};
export declare type IssueHistoryConnection = {
    __typename?: "IssueHistoryConnection";
    edges: Array<IssueHistoryEdge>;
    nodes: Array<IssueHistory>;
    pageInfo: PageInfo;
};
export declare type IssueHistoryEdge = {
    __typename?: "IssueHistoryEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueHistory;
};
/** An import job for data from an external service */
export declare type IssueImport = Node & {
    __typename?: "IssueImport";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The id for the user that started the job. */
    creatorId: Scalars["String"];
    /** User readable error message, if one has occurred during the import. */
    error?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The service from which data will be imported. */
    service: Scalars["String"];
    /** The status for the import job. */
    status: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueImportDeletePayload = {
    __typename?: "IssueImportDeletePayload";
    /** The import job that was deleted. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueImportPayload = {
    __typename?: "IssueImportPayload";
    /** The import job that was created or updated. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabel = Node & {
    __typename?: "IssueLabel";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The label's color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the label. */
    creator?: Maybe<User>;
    /** The label's description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issues associated with the label. */
    issues: IssueConnection;
    /** The label's name. */
    name: Scalars["String"];
    /** The team to which the label belongs to. */
    team: Team;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabelIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueLabelConnection = {
    __typename?: "IssueLabelConnection";
    edges: Array<IssueLabelEdge>;
    nodes: Array<IssueLabel>;
    pageInfo: PageInfo;
};
export declare type IssueLabelCreateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name: Scalars["String"];
    /** The team associated with the label. */
    teamId: Scalars["String"];
};
export declare type IssueLabelEdge = {
    __typename?: "IssueLabelEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueLabel;
};
export declare type IssueLabelPayload = {
    __typename?: "IssueLabelPayload";
    /** The label that was created or updated. */
    issueLabel: IssueLabel;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueLabelUpdateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name?: Maybe<Scalars["String"]>;
};
export declare type IssuePayload = {
    __typename?: "IssuePayload";
    /** The issue that was created or updated. */
    issue?: Maybe<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssuePriorityValue = {
    __typename?: "IssuePriorityValue";
    /** Priority's label. */
    label: Scalars["String"];
    /** Priority's number value. */
    priority: Scalars["Int"];
};
/** A relation between two issues. */
export declare type IssueRelation = Node & {
    __typename?: "IssueRelation";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue whose relationship is being described. */
    issue: Issue;
    /** The related issue. */
    relatedIssue: Issue;
    /** The relationship of the issue with the related issue. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueRelationConnection = {
    __typename?: "IssueRelationConnection";
    edges: Array<IssueRelationEdge>;
    nodes: Array<IssueRelation>;
    pageInfo: PageInfo;
};
export declare type IssueRelationCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue that is related to another issue. */
    issueId: Scalars["String"];
    /** The identifier of the related issue. */
    relatedIssueId: Scalars["String"];
    /** The type of relation of the issue to the related issue. */
    type: IssueRelationType;
};
export declare type IssueRelationEdge = {
    __typename?: "IssueRelationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueRelation;
};
export declare type IssueRelationPayload = {
    __typename?: "IssueRelationPayload";
    /** The issue relation that was created or updated. */
    issueRelation: IssueRelation;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The type of the issue relation. */
export declare enum IssueRelationType {
    Blocks = "blocks",
    Duplicate = "duplicate",
    Related = "related"
}
export declare type IssueRelationUpdateInput = {
    /** The identifier of the issue that is related to another issue. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the related issue. */
    relatedIssueId?: Maybe<Scalars["String"]>;
    /** The type of relation of the issue to the related issue. */
    type?: Maybe<Scalars["String"]>;
};
export declare type IssueUpdateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** [DEPRECATED] Document version for backwards compatibility. */
    documentVersion?: Maybe<Scalars["Int"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId?: Maybe<Scalars["String"]>;
    /** The issue title. */
    title?: Maybe<Scalars["String"]>;
};
export declare type JoinOrganizationInput = {
    /** The identifier of the organization. */
    organizationId: Scalars["String"];
};
/** A milestone that contains projects. */
export declare type Milestone = Node & {
    __typename?: "Milestone";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the milestone. */
    name: Scalars["String"];
    /** The organization that the milestone belongs to. */
    organization: Organization;
    /** Projects associated with the milestone. */
    projects: ProjectConnection;
    /** The sort order for the milestone. */
    sortOrder: Scalars["Float"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A milestone that contains projects. */
export declare type MilestoneProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type MilestoneConnection = {
    __typename?: "MilestoneConnection";
    edges: Array<MilestoneEdge>;
    nodes: Array<Milestone>;
    pageInfo: PageInfo;
};
export declare type MilestoneCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the milestone. */
    name: Scalars["String"];
    /** The sort order of the milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type MilestoneEdge = {
    __typename?: "MilestoneEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Milestone;
};
export declare type MilestonePayload = {
    __typename?: "MilestonePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The milesteone that was created or updated. */
    milestone?: Maybe<Milestone>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type MilestoneUpdateInput = {
    /** The name of the milestone. */
    name?: Maybe<Scalars["String"]>;
    /** The sort order of the milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type Mutation = {
    __typename?: "Mutation";
    /** Creates a new API key. */
    apiKeyCreate: ApiKeyPayload;
    /** Deletes an API key. */
    apiKeyDelete: ArchivePayload;
    /** [Alpha] Archives an issue attachment. */
    attachmentArchive: ArchivePayload;
    /** [Alpha] Creates a new attachment, or updates existing if the same `uri` is used. */
    attachmentCreate: AttachmentPayload;
    /** [Alpha] Updates an existing issue attachment. */
    attachmentUpdate: AttachmentPayload;
    /** Updates the billing email address for the customer. */
    billingEmailUpdate: BillingEmailPayload;
    /** Update collaborative document with client steps. */
    collaborativeDocumentUpdate: CollaborationDocumentUpdatePayload;
    /** Creates a new comment. */
    commentCreate: CommentPayload;
    /** Deletes a comment. */
    commentDelete: ArchivePayload;
    /** Updates a comment. */
    commentUpdate: CommentPayload;
    /** Saves user message. */
    contactCreate: ContactPayload;
    /** Create CSV export report for the organization. */
    createCsvExportReport: CreateCsvExportReportPayload;
    /** Creates an organization from onboarding. */
    createOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Creates a new custom view. */
    customViewCreate: CustomViewPayload;
    /** Deletes a custom view. */
    customViewDelete: ArchivePayload;
    /** Updates a custom view. */
    customViewUpdate: CustomViewPayload;
    /** Archives a cycle. */
    cycleArchive: ArchivePayload;
    /** Creates a new cycle. */
    cycleCreate: CyclePayload;
    /** Updates a cycle. */
    cycleUpdate: CyclePayload;
    /** Create the SAML test organization in development. */
    debugCreateSAMLOrg: DebugPayload;
    /** Always fails with internal error. Used to debug logging. */
    debugFailWithInternalError: DebugPayload;
    /** Always logs an error to Sentry as warning. Used to debug logging. */
    debugFailWithWarning: DebugPayload;
    /** Authenticates a user account via email and authentication token. */
    emailTokenUserAccountAuth: AuthResolverResponse;
    /** Unsubscribes the user from one type of emails. */
    emailUnsubscribe: EmailUnsubscribePayload;
    /** Finds or creates a new user account by email and sends an email with token. */
    emailUserAccountAuthChallenge: EmailUserAccountAuthChallengeResponse;
    /** Creates a custom emoji. */
    emojiCreate: EmojiPayload;
    /** Deletes an emoji. */
    emojiDelete: ArchivePayload;
    /** [Deprecated] Creates a new event. */
    eventCreate: EventPayload;
    /** Creates a new favorite (project, cycle etc). */
    favoriteCreate: FavoritePayload;
    /** Deletes a favorite reference. */
    favoriteDelete: ArchivePayload;
    /** Updates a favorite. */
    favoriteUpdate: FavoritePayload;
    /** Saves user feedback. */
    feedbackCreate: FeedbackPayload;
    /** XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage. */
    fileUpload: UploadPayload;
    /** Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow. */
    googleUserAccountAuth: AuthResolverResponse;
    /** Upload an image from an URL to Linear. */
    imageUploadFromUrl: ImageUploadFromUrlPayload;
    /** Deletes an integration. */
    integrationDelete: ArchivePayload;
    /** Integrates the organization with Figma. */
    integrationFigma: IntegrationPayload;
    /** Connects the organization with the GitHub App. */
    integrationGithubConnect: IntegrationPayload;
    /** Connects the organization with a GitLab Access Token. */
    integrationGitlabConnect: IntegrationPayload;
    /** Integrates the organization with Google Sheets. */
    integrationGoogleSheets: IntegrationPayload;
    /** Archives an integration resource. */
    integrationResourceArchive: ArchivePayload;
    /** Integrates the organization with Sentry. */
    integrationSentryConnect: IntegrationPayload;
    /** Integrates the organization with Slack. */
    integrationSlack: IntegrationPayload;
    /** Imports custom emojis from your Slack workspace. */
    integrationSlackImportEmojis: IntegrationPayload;
    /** Integrates your personal notifications with Slack. */
    integrationSlackPersonal: IntegrationPayload;
    /** Slack webhook integration. */
    integrationSlackPost: IntegrationPayload;
    /** Slack integration for project notifications. */
    integrationSlackProjectPost: IntegrationPayload;
    /** Integrates the organization with Zendesk. */
    integrationZendesk: IntegrationPayload;
    /** Archives an issue. */
    issueArchive: ArchivePayload;
    /** Creates a new issue. */
    issueCreate: IssuePayload;
    /** Kicks off an Asana import job. */
    issueImportCreateAsana: IssueImportPayload;
    /** Kicks off a Clubhouse import job. */
    issueImportCreateClubhouse: IssueImportPayload;
    /** Kicks off a GitHub import job. */
    issueImportCreateGithub: IssueImportPayload;
    /** Kicks off a Jira import job. */
    issueImportCreateJira: IssueImportPayload;
    /** Deletes an import job. */
    issueImportDelete: IssueImportDeletePayload;
    /** Archives an issue label. */
    issueLabelArchive: ArchivePayload;
    /** Creates a new label. */
    issueLabelCreate: IssueLabelPayload;
    /** Updates an label. */
    issueLabelUpdate: IssueLabelPayload;
    /** Creates a new issue relation. */
    issueRelationCreate: IssueRelationPayload;
    /** Deletes an issue relation. */
    issueRelationDelete: ArchivePayload;
    /** Updates an issue relation. */
    issueRelationUpdate: IssueRelationPayload;
    /** Unarchives an issue. */
    issueUnarchive: ArchivePayload;
    /** Updates an issue. */
    issueUpdate: IssuePayload;
    /** Join an organization from onboarding. */
    joinOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Leave an organization. */
    leaveOrganization: CreateOrJoinOrganizationResponse;
    /** Creates a new milestone. */
    milestoneCreate: MilestonePayload;
    /** Deletes a milestone. */
    milestoneDelete: ArchivePayload;
    /** Updates a milestone. */
    milestoneUpdate: MilestonePayload;
    /** Archives a notification. */
    notificationArchive: ArchivePayload;
    /** Creates a notification. */
    notificationCreate: NotificationPayload;
    /** [Deprecated] Deletes a notification. */
    notificationDelete: ArchivePayload;
    /** Creates a new notification subscription for a team or a project. */
    notificationSubscriptionCreate: NotificationSubscriptionPayload;
    /** Deletes a notification subscription reference. */
    notificationSubscriptionDelete: ArchivePayload;
    /** Unarchives a notification. */
    notificationUnarchive: ArchivePayload;
    /** Updates a notification. */
    notificationUpdate: NotificationPayload;
    /** Archives an OAuth client. */
    oauthClientArchive: ArchivePayload;
    /** Creates a new OAuth client. */
    oauthClientCreate: OauthClientPayload;
    /** Updates an OAuth client. */
    oauthClientRotateSecret: RotateSecretPayload;
    /** Updates an OAuth client. */
    oauthClientUpdate: OauthClientPayload;
    /** Revokes an OAuth token. */
    oauthTokenRevoke: OauthTokenRevokePayload;
    /** Delete's an organization. Administrator privileges required. */
    organizationDelete: OrganizationDeletePayload;
    /** Get an organization's delete confirmation token. Administrator privileges required. */
    organizationDeleteChallenge: OrganizationDeletePayload;
    /** Adds a domain to be allowed for an organization. */
    organizationDomainCreate: OrganizationDomainPayload;
    /** Deletes a domain. */
    organizationDomainDelete: ArchivePayload;
    /** Verifies a domain to be added to an organization. */
    organizationDomainVerify: OrganizationDomainPayload;
    /** Creates a new organization invite. */
    organizationInviteCreate: OrganizationInvitePayload;
    /** Deletes an organization invite. */
    organizationInviteDelete: ArchivePayload;
    /** Updates the user's organization. */
    organizationUpdate: OrganizationPayload;
    /** Archives a project. */
    projectArchive: ArchivePayload;
    /** Creates a new project. */
    projectCreate: ProjectPayload;
    /** Creates a new project link. */
    projectLinkCreate: ProjectLinkPayload;
    /** Deletes a project link. */
    projectLinkDelete: ArchivePayload;
    /** Updates a project. */
    projectUpdate: ProjectPayload;
    /** Creates a push subscription. */
    pushSubscriptionCreate: PushSubscriptionPayload;
    /** Deletes a push subscription. */
    pushSubscriptionDelete: PushSubscriptionPayload;
    /** Creates a new reaction. */
    reactionCreate: ReactionPayload;
    /** Deletes a reaction. */
    reactionDelete: ArchivePayload;
    /** Manually update Google Sheets data. */
    refreshGoogleSheetsData: IntegrationPayload;
    /** Re-send an organization invite. */
    resentOrganizationInvite: ArchivePayload;
    /** Authenticates a user account via email and authentication token for SAML. */
    samlTokenUserAccountAuth: AuthResolverResponse;
    /** Archives a subscription. */
    subscriptionArchive: ArchivePayload;
    /** Creates a subscription session. Used internally to integrate with Stripe. */
    subscriptionSessionCreate: SubscriptionSessionPayload;
    /** Updates a subscription. */
    subscriptionUpdate: SubscriptionPayload;
    /** Creates a subscription update session. Used internally to integrate with Stripe. */
    subscriptionUpdateSessionCreate: SubscriptionSessionPayload;
    /** Upgrades a subscription plan. */
    subscriptionUpgrade: SubscriptionPayload;
    /** Archives a team. */
    teamArchive: ArchivePayload;
    /** Creates a new team. The user who creates the team will automatically be added as a member to the newly created team. */
    teamCreate: TeamPayload;
    /** Deletes a team. */
    teamDelete: ArchivePayload;
    /** Creates a new team membership. */
    teamMembershipCreate: TeamMembershipPayload;
    /** Deletes a team membership. */
    teamMembershipDelete: ArchivePayload;
    /** Updates a team membership. */
    teamMembershipUpdate: TeamMembershipPayload;
    /** Updates a team. */
    teamUpdate: TeamPayload;
    /** Creates a new template. */
    templateCreate: TemplatePayload;
    /** Deletes a template. */
    templateDelete: ArchivePayload;
    /** Updates an existing template. */
    templateUpdate: TemplatePayload;
    /** Makes user a regular user. Can only be called by an admin. */
    userDemoteAdmin: UserAdminPayload;
    /** Updates a user's settings flag. */
    userFlagUpdate: UserSettingsFlagPayload;
    /** Makes user an admin. Can only be called by an admin. */
    userPromoteAdmin: UserAdminPayload;
    /** [Deprecated] Updates a user's settings flag. */
    userSettingsFlagIncrement: UserSettingsFlagPayload;
    /** Resets user's setting flags. */
    userSettingsFlagsReset: UserSettingsFlagsResetPayload;
    /** Updates the user's settings. */
    userSettingsUpdate: UserSettingsPayload;
    /** Subscribes user to changelog newsletter. */
    userSubscribeToNewsletter: UserSubscribeToNewsletterPayload;
    /** Suspends a user. Can only be called by an admin. */
    userSuspend: UserAdminPayload;
    /** Un-suspends a user. Can only be called by an admin. */
    userUnsuspend: UserAdminPayload;
    /** Updates a user. Only available to organization admins and the user themselves. */
    userUpdate: UserPayload;
    /** Creates a new ViewPreferences object. */
    viewPreferencesCreate: ViewPreferencesPayload;
    /** Deletes a ViewPreferences. */
    viewPreferencesDelete: ArchivePayload;
    /** Updates an existing ViewPreferences object. */
    viewPreferencesUpdate: ViewPreferencesPayload;
    /** Creates a new webhook. */
    webhookCreate: WebhookPayload;
    /** Deletes a Webhook. */
    webhookDelete: ArchivePayload;
    /** Updates an existing Webhook. */
    webhookUpdate: WebhookPayload;
    /** Archives a state. Only states with issues that have all been archived can be archived. */
    workflowStateArchive: ArchivePayload;
    /** Creates a new state, adding it to the workflow of a team. */
    workflowStateCreate: WorkflowStatePayload;
    /** Updates a state. */
    workflowStateUpdate: WorkflowStatePayload;
};
export declare type MutationApiKeyCreateArgs = {
    input: ApiKeyCreateInput;
};
export declare type MutationApiKeyDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentCreateArgs = {
    input: AttachmentCreateInput;
};
export declare type MutationAttachmentUpdateArgs = {
    id: Scalars["String"];
    input: AttachmentUpdateInput;
};
export declare type MutationBillingEmailUpdateArgs = {
    input: BillingEmailUpdateInput;
};
export declare type MutationCollaborativeDocumentUpdateArgs = {
    input: CollaborationDocumentUpdateInput;
};
export declare type MutationCommentCreateArgs = {
    input: CommentCreateInput;
};
export declare type MutationCommentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCommentUpdateArgs = {
    id: Scalars["String"];
    input: CommentUpdateInput;
};
export declare type MutationContactCreateArgs = {
    input: ContactCreateInput;
};
export declare type MutationCreateCsvExportReportArgs = {
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type MutationCreateOrganizationFromOnboardingArgs = {
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
};
export declare type MutationCustomViewCreateArgs = {
    input: CustomViewCreateInput;
};
export declare type MutationCustomViewDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCustomViewUpdateArgs = {
    id: Scalars["String"];
    input: CustomViewUpdateInput;
};
export declare type MutationCycleArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationCycleCreateArgs = {
    input: CycleCreateInput;
};
export declare type MutationCycleUpdateArgs = {
    id: Scalars["String"];
    input: CycleUpdateInput;
};
export declare type MutationEmailTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationEmailUnsubscribeArgs = {
    input: EmailUnsubscribeInput;
};
export declare type MutationEmailUserAccountAuthChallengeArgs = {
    input: EmailUserAccountAuthChallengeInput;
};
export declare type MutationEmojiCreateArgs = {
    input: EmojiCreateInput;
};
export declare type MutationEmojiDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationEventCreateArgs = {
    input: EventCreateInput;
};
export declare type MutationFavoriteCreateArgs = {
    input: FavoriteCreateInput;
};
export declare type MutationFavoriteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationFavoriteUpdateArgs = {
    id: Scalars["String"];
    input: FavoriteUpdateInput;
};
export declare type MutationFeedbackCreateArgs = {
    input: FeedbackCreateInput;
};
export declare type MutationFileUploadArgs = {
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
};
export declare type MutationGoogleUserAccountAuthArgs = {
    input: GoogleUserAccountAuthInput;
};
export declare type MutationImageUploadFromUrlArgs = {
    url: Scalars["String"];
};
export declare type MutationIntegrationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationFigmaArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationGithubConnectArgs = {
    installationId: Scalars["String"];
};
export declare type MutationIntegrationGitlabConnectArgs = {
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
};
export declare type MutationIntegrationGoogleSheetsArgs = {
    code: Scalars["String"];
};
export declare type MutationIntegrationResourceArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationSentryConnectArgs = {
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
};
export declare type MutationIntegrationSlackArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIntegrationSlackImportEmojisArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPersonalArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPostArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIntegrationSlackProjectPostArgs = {
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationZendeskArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
};
export declare type MutationIssueArchiveArgs = {
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIssueCreateArgs = {
    input: IssueCreateInput;
};
export declare type MutationIssueImportCreateAsanaArgs = {
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateClubhouseArgs = {
    clubhouseTeamName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateGithubArgs = {
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    teamId: Scalars["String"];
};
export declare type MutationIssueImportCreateJiraArgs = {
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    teamId: Scalars["String"];
};
export declare type MutationIssueImportDeleteArgs = {
    issueImportId: Scalars["String"];
};
export declare type MutationIssueLabelArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueLabelCreateArgs = {
    input: IssueLabelCreateInput;
};
export declare type MutationIssueLabelUpdateArgs = {
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
};
export declare type MutationIssueRelationCreateArgs = {
    input: IssueRelationCreateInput;
};
export declare type MutationIssueRelationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueRelationUpdateArgs = {
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
};
export declare type MutationIssueUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueUpdateArgs = {
    id: Scalars["String"];
    input: IssueUpdateInput;
};
export declare type MutationJoinOrganizationFromOnboardingArgs = {
    input: JoinOrganizationInput;
};
export declare type MutationLeaveOrganizationArgs = {
    organizationId: Scalars["String"];
};
export declare type MutationMilestoneCreateArgs = {
    input: MilestoneCreateInput;
};
export declare type MutationMilestoneDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationMilestoneUpdateArgs = {
    id: Scalars["String"];
    input: MilestoneUpdateInput;
};
export declare type MutationNotificationArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationCreateArgs = {
    id: Scalars["String"];
    input: NotificationUpdateInput;
};
export declare type MutationNotificationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationSubscriptionCreateArgs = {
    input: NotificationSubscriptionCreateInput;
};
export declare type MutationNotificationSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationUpdateArgs = {
    id: Scalars["String"];
    input: NotificationUpdateInput;
};
export declare type MutationOauthClientArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationOauthClientCreateArgs = {
    input: OauthClientCreateInput;
};
export declare type MutationOauthClientRotateSecretArgs = {
    id: Scalars["String"];
};
export declare type MutationOauthClientUpdateArgs = {
    id: Scalars["String"];
    input: OauthClientUpdateInput;
};
export declare type MutationOauthTokenRevokeArgs = {
    appId: Scalars["String"];
    scope: Array<Scalars["String"]>;
};
export declare type MutationOrganizationDeleteArgs = {
    input: DeleteOrganizationInput;
};
export declare type MutationOrganizationDomainCreateArgs = {
    input: OrganizationDomainCreateInput;
};
export declare type MutationOrganizationDomainDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationDomainVerifyArgs = {
    input: OrganizationDomainVerificationInput;
};
export declare type MutationOrganizationInviteCreateArgs = {
    input: OrganizationInviteCreateInput;
};
export declare type MutationOrganizationInviteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationUpdateArgs = {
    input: UpdateOrganizationInput;
};
export declare type MutationProjectArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectCreateArgs = {
    input: ProjectCreateInput;
};
export declare type MutationProjectLinkCreateArgs = {
    input: ProjectLinkCreateInput;
};
export declare type MutationProjectLinkDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectUpdateArgs = {
    id: Scalars["String"];
    input: ProjectUpdateInput;
};
export declare type MutationPushSubscriptionCreateArgs = {
    input: PushSubscriptionCreateInput;
};
export declare type MutationPushSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationReactionCreateArgs = {
    input: ReactionCreateInput;
};
export declare type MutationReactionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationRefreshGoogleSheetsDataArgs = {
    id: Scalars["String"];
};
export declare type MutationResentOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type MutationSamlTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationSubscriptionArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationSubscriptionSessionCreateArgs = {
    plan: Scalars["String"];
};
export declare type MutationSubscriptionUpdateArgs = {
    id: Scalars["String"];
    input: SubscriptionUpdateInput;
};
export declare type MutationSubscriptionUpgradeArgs = {
    id: Scalars["String"];
    type: Scalars["String"];
};
export declare type MutationTeamArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamCreateArgs = {
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
};
export declare type MutationTeamDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipCreateArgs = {
    input: TeamMembershipCreateInput;
};
export declare type MutationTeamMembershipDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipUpdateArgs = {
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
};
export declare type MutationTeamUpdateArgs = {
    id: Scalars["String"];
    input: TeamUpdateInput;
};
export declare type MutationTemplateCreateArgs = {
    input: TemplateCreateInput;
};
export declare type MutationTemplateDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTemplateUpdateArgs = {
    id: Scalars["String"];
    input: TemplateUpdateInput;
};
export declare type MutationUserDemoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserFlagUpdateArgs = {
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
};
export declare type MutationUserPromoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserSettingsFlagIncrementArgs = {
    flag: Scalars["String"];
};
export declare type MutationUserSettingsUpdateArgs = {
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
};
export declare type MutationUserSuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUnsuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUpdateArgs = {
    id: Scalars["String"];
    input: UpdateUserInput;
};
export declare type MutationViewPreferencesCreateArgs = {
    input: ViewPreferencesCreateInput;
};
export declare type MutationViewPreferencesDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationViewPreferencesUpdateArgs = {
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
};
export declare type MutationWebhookCreateArgs = {
    input: WebhookCreateInput;
};
export declare type MutationWebhookDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationWebhookUpdateArgs = {
    id: Scalars["String"];
    input: WebhookUpdateInput;
};
export declare type MutationWorkflowStateArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationWorkflowStateCreateArgs = {
    input: WorkflowStateCreateInput;
};
export declare type MutationWorkflowStateUpdateArgs = {
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
};
export declare type Node = {
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
};
/** A notification sent to a user. */
export declare type Notification = Node & {
    __typename?: "Notification";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment which the notification is associated with. */
    comment?: Maybe<Comment>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the notification is associated with. */
    issue: Issue;
    /** Name of the reaction emoji associated with the notification. */
    reactionEmoji?: Maybe<Scalars["String"]>;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The team which the notification is associated with. */
    team: Team;
    /** Notification type */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The recipient of the notification. */
    user: User;
};
export declare type NotificationConnection = {
    __typename?: "NotificationConnection";
    edges: Array<NotificationEdge>;
    nodes: Array<Notification>;
    pageInfo: PageInfo;
};
export declare type NotificationEdge = {
    __typename?: "NotificationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Notification;
};
export declare type NotificationPayload = {
    __typename?: "NotificationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification that was created or updated. */
    notification: Notification;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Notification subscriptions for models. */
export declare type NotificationSubscription = Node & {
    __typename?: "NotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Subscribed project. */
    project?: Maybe<Project>;
    /** Subscribed team. */
    team?: Maybe<Team>;
    /** The type of the subscription. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user associated with notification subscriptions. */
    user: User;
};
export declare type NotificationSubscriptionConnection = {
    __typename?: "NotificationSubscriptionConnection";
    edges: Array<NotificationSubscriptionEdge>;
    nodes: Array<NotificationSubscription>;
    pageInfo: PageInfo;
};
export declare type NotificationSubscriptionCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project to subscribe to. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the team to subscribe to. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type NotificationSubscriptionEdge = {
    __typename?: "NotificationSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: NotificationSubscription;
};
export declare type NotificationSubscriptionPayload = {
    __typename?: "NotificationSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification subscription that was created or updated. */
    notificationSubscription: NotificationSubscription;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type NotificationUpdateInput = {
    /** The time when notification was marked as read. */
    readAt?: Maybe<Scalars["DateTime"]>;
};
/** GitHub OAuth token, plus information about the organizations the user is a member of. */
export declare type OAuthTokenPayload = {
    __typename?: "OAuthTokenPayload";
    /** A list of the GitHub orgs the user is a member of with attached repositories. */
    organizations?: Maybe<Array<GithubOrg>>;
    /** The OAuth token if the operation to fetch it was successful. */
    token?: Maybe<Scalars["String"]>;
};
/** OAuth2 client application */
export declare type OauthClient = Node & {
    __typename?: "OauthClient";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** OAuth application's client secret. */
    clientSecret: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Information about the application. */
    description: Scalars["String"];
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer. */
    developerUrl: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Image of the application. */
    imageUrl: Scalars["String"];
    /** OAuth application's client name. */
    name: Scalars["String"];
    /** List of allowed redirect URIs for the application. */
    redirectUris: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type OauthClientCreateInput = {
    /** User facing description of the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer of the application. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** URL for the app icon. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** The application's name. */
    name: Scalars["String"];
    /** List of allowed redirect URIs for the application. */
    redirectUris: Array<Scalars["String"]>;
};
export declare type OauthClientPayload = {
    __typename?: "OauthClientPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The OAuth client application that was created or updated. */
    oauthClient: OauthClient;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OauthClientUpdateInput = {
    /** User facing description of the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer of the application. */
    developer?: Maybe<Scalars["String"]>;
    /** URL of the developer (homepage or docs). */
    developerUrl?: Maybe<Scalars["String"]>;
    /** URL for the app icon. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** The application's name. */
    name?: Maybe<Scalars["String"]>;
    /** List of allowed redirect URIs for the application. */
    redirectUris?: Maybe<Array<Scalars["String"]>>;
};
export declare type OauthTokenRevokePayload = {
    __typename?: "OauthTokenRevokePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OnboardingCustomerSurvey = {
    companyRole?: Maybe<Scalars["String"]>;
    companySize?: Maybe<Scalars["String"]>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type Organization = Node & {
    __typename?: "Organization";
    /** Allowed authentication providers, empty array means all are allowed */
    allowedAuthServices: Array<Scalars["String"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues in the organization. */
    createdIssueCount: Scalars["Int"];
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent to private repositories. */
    gitLinkbackMessagesEnabled: Scalars["Boolean"];
    /** Whether the Git integration linkback messages should be sent to public repositories. */
    gitPublicLinkbackMessagesEnabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Integrations associated with the organization. */
    integrations: IntegrationConnection;
    /** The organization's logo URL. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** Milestones associated with the organization. */
    milestones: MilestoneConnection;
    /** The organization's name. */
    name: Scalars["String"];
    /** Rolling 30-day total upload volume for the organization, in megabytes. */
    periodUploadVolume: Scalars["Float"];
    /** Whether the organization is using a roadmap. */
    roadmapEnabled: Scalars["Boolean"];
    /** Whether SAML authentication is enabled for organization. */
    samlEnabled: Scalars["Boolean"];
    /** The organization's subscription to a paid plan. */
    subscription?: Maybe<Subscription>;
    /** Teams associated with the organization. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The organization's unique URL key. */
    urlKey: Scalars["String"];
    /** Number of active users in the organization. */
    userCount: Scalars["Int"];
    /** Users associated with the organization. */
    users: UserConnection;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type OrganizationDeletePayload = {
    __typename?: "OrganizationDeletePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Defines the use of a domain by an organization. */
export declare type OrganizationDomain = Node & {
    __typename?: "OrganizationDomain";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who added the domain. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Domain name */
    name: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** E-mail used to verify this domain */
    verificationEmail?: Maybe<Scalars["String"]>;
    /** Is this domain verified */
    verified: Scalars["Boolean"];
};
export declare type OrganizationDomainCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The domain name to add. */
    name: Scalars["String"];
    /** The email address to which to send the verification code. */
    verificationEmail: Scalars["String"];
    /** Is the domain verified. */
    verified: Scalars["Boolean"];
};
export declare type OrganizationDomainPayload = {
    __typename?: "OrganizationDomainPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization domain that was created or updated. */
    organizationDomain: OrganizationDomain;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDomainSimplePayload = {
    __typename?: "OrganizationDomainSimplePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDomainVerificationInput = {
    /** The identifier of the domain being verified. */
    organizationDomainId: Scalars["String"];
    /** The verification code sent via email. */
    verificationCode: Scalars["String"];
};
export declare type OrganizationExistsPayload = {
    __typename?: "OrganizationExistsPayload";
    /** Whether the organization exists. */
    exists: Scalars["Boolean"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** An invitation to the organization that has been sent via email. */
export declare type OrganizationInvite = Node & {
    __typename?: "OrganizationInvite";
    /** The time at which the invite was accepted. Null, if the invite hasn't been accepted */
    acceptedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The invitees email address. */
    email: Scalars["String"];
    /** The time at which the invite will be expiring. Null, if the invite shouldn't expire */
    expiresAt?: Maybe<Scalars["DateTime"]>;
    /** The invite was sent to external address. */
    external: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
    invitee?: Maybe<User>;
    /** The user who created the invitation. */
    inviter: User;
    /** The organization that the invite is associated with. */
    organization: Organization;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type OrganizationInviteConnection = {
    __typename?: "OrganizationInviteConnection";
    edges: Array<OrganizationInviteEdge>;
    nodes: Array<OrganizationInvite>;
    pageInfo: PageInfo;
};
export declare type OrganizationInviteCreateInput = {
    /** The email of the invitee. */
    email: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The message to send to the invitee. */
    message?: Maybe<Scalars["String"]>;
    /** The teams that the user has been invited to. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type OrganizationInviteEdge = {
    __typename?: "OrganizationInviteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: OrganizationInvite;
};
export declare type OrganizationInvitePayload = {
    __typename?: "OrganizationInvitePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization invite that was created or updated. */
    organizationInvite: OrganizationInvite;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationPayload = {
    __typename?: "OrganizationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization that was created or updated. */
    organization?: Maybe<Organization>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type PageInfo = {
    __typename?: "PageInfo";
    /** Cursor representing the last result in the paginated results. */
    endCursor?: Maybe<Scalars["String"]>;
    /** Indicates if there are more results when paginating forward. */
    hasNextPage: Scalars["Boolean"];
    /** Indicates if there are more results when paginating backward. */
    hasPreviousPage: Scalars["Boolean"];
    /** Cursor representing the first result in the paginated results. */
    startCursor?: Maybe<Scalars["String"]>;
};
/** By which field should the pagination order by */
export declare enum PaginationOrderBy {
    CreatedAt = "createdAt",
    UpdatedAt = "updatedAt"
}
/** A project. */
export declare type Project = Node & {
    __typename?: "Project";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The project's color. */
    color: Scalars["String"];
    /** The time at which the project was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each week. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the project. */
    creator: User;
    /** The project's description. */
    description: Scalars["String"];
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The total number of issues in the project after each week. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the project. */
    issues: IssueConnection;
    /** The project lead. */
    lead?: Maybe<User>;
    /** Links associated with the project. */
    links: ProjectLinkConnection;
    /** Users that are members of the project. */
    members: UserConnection;
    /** The milestone that this project is associated with. */
    milestone?: Maybe<Milestone>;
    /** The project's name. */
    name: Scalars["String"];
    /** The total number of estimation points after each week. */
    scopeHistory: Array<Scalars["Float"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The project's unique URL slug. */
    slugId: Scalars["String"];
    /** The sort order for the project within its milestone. */
    sortOrder: Scalars["Float"];
    /** The time at which the project was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of the state. */
    state: Scalars["String"];
    /** The estimated completion date of the project. */
    targetDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** Teams associated with this project. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A project. */
export declare type ProjectIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectConnection = {
    __typename?: "ProjectConnection";
    edges: Array<ProjectEdge>;
    nodes: Array<Project>;
    pageInfo: PageInfo;
};
export declare type ProjectCreateInput = {
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the milestone to associate the project with. */
    milestoneId?: Maybe<Scalars["String"]>;
    /** The name of the project. */
    name: Scalars["String"];
    /** The sort order for the project within its milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds: Array<Scalars["String"]>;
};
export declare type ProjectEdge = {
    __typename?: "ProjectEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Project;
};
/** An external link for a project. */
export declare type ProjectLink = Node & {
    __typename?: "ProjectLink";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the link. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The link's label. */
    label: Scalars["String"];
    /** The project that the link is associated with. */
    project: Project;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The link's URL. */
    url: Scalars["String"];
};
export declare type ProjectLinkConnection = {
    __typename?: "ProjectLinkConnection";
    edges: Array<ProjectLinkEdge>;
    nodes: Array<ProjectLink>;
    pageInfo: PageInfo;
};
export declare type ProjectLinkCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The label for the link. */
    label: Scalars["String"];
    /** Related project for the link. */
    projectId: Scalars["String"];
    /** The URL of the link. */
    url: Scalars["String"];
};
export declare type ProjectLinkEdge = {
    __typename?: "ProjectLinkEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectLink;
};
export declare type ProjectLinkPayload = {
    __typename?: "ProjectLinkPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    projectLink: ProjectLink;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectPayload = {
    __typename?: "ProjectPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    project?: Maybe<Project>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectUpdateInput = {
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the milestone to associate the project with. */
    milestoneId?: Maybe<Scalars["String"]>;
    /** The name of the project. */
    name?: Maybe<Scalars["String"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The sort order for the project within its milestone. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDateScalar"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
/** Pull request data */
export declare type PullRequestPayload = {
    __typename?: "PullRequestPayload";
    branch: Scalars["String"];
    closedAt: Scalars["String"];
    createdAt: Scalars["String"];
    draft: Scalars["Boolean"];
    id: Scalars["String"];
    mergedAt: Scalars["String"];
    number: Scalars["Float"];
    repoLogin: Scalars["String"];
    repoName: Scalars["String"];
    status: Scalars["String"];
    title: Scalars["String"];
    updatedAt: Scalars["String"];
    url: Scalars["String"];
    userId: Scalars["String"];
    userLogin: Scalars["String"];
};
/** A user's web browser push notification subscription. */
export declare type PushSubscription = Node & {
    __typename?: "PushSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type PushSubscriptionConnection = {
    __typename?: "PushSubscriptionConnection";
    edges: Array<PushSubscriptionEdge>;
    nodes: Array<PushSubscription>;
    pageInfo: PageInfo;
};
export declare type PushSubscriptionCreateInput = {
    /** The data of the subscription in stringified JSON format. */
    data: Scalars["String"];
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The user identifier of the subscription. */
    userId: Scalars["String"];
};
export declare type PushSubscriptionEdge = {
    __typename?: "PushSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: PushSubscription;
};
export declare type PushSubscriptionPayload = {
    __typename?: "PushSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type Query = {
    __typename?: "Query";
    /** All API keys for the user. */
    apiKeys: ApiKeyConnection;
    /** Get information for an application and whether a user has approved it for the given scopes. */
    applicationWithAuthorization: UserAuthorizedApplication;
    /** Fetches an archived model. */
    archivedModelSync: ArchiveResponse;
    /** Fetches archived models. */
    archivedModelsSync: ArchiveResponse;
    /** [Alpha] One specific issue attachment. `url` can be used as the `id` parameter. */
    attachment: Attachment;
    /** [Alpha] Query an issue by its associated attachment, and its id or URI. */
    attachmentIssue: Issue;
    /** [Alpha] All issue attachments. */
    attachments: AttachmentConnection;
    /** Get all authorized applications for a user */
    authorizedApplications: Array<AuthorizedApplication>;
    /** Fetch users belonging to this user account. */
    availableUsers: AuthResolverResponse;
    /** Billing details for the customer. */
    billingDetails: BillingDetailsPayload;
    /** Join collaborative document and get missing steps. */
    collaborativeDocumentJoin: CollaborationDocumentUpdatePayload;
    /** A specific comment. */
    comment: Comment;
    /** All comments. */
    comments: CommentConnection;
    /** One specific custom view. */
    customView: CustomView;
    /** Custom views for the user. */
    customViews: CustomViewConnection;
    /** One specific cycle. */
    cycle: Cycle;
    /** All cycles. */
    cycles: CycleConnection;
    /** A specific emoji. */
    emoji: Emoji;
    /** All custom emojis. */
    emojis: EmojiConnection;
    /** One specific favorite. */
    favorite: Favorite;
    /** The user's favorites. */
    favorites: FavoriteConnection;
    /** Fetch Figma screenshot and other information with file and node identifiers. */
    figmaEmbedInfo: FigmaEmbedPayload;
    /** One specific integration. */
    integration: Integration;
    /** One specific integration resource. (e.g. linked GitHub pull requests for an issue) */
    integrationResource: IntegrationResource;
    /** All integrations resources (e.g. linked GitHub pull requests for issues). */
    integrationResources: IntegrationResourceConnection;
    /** All integrations. */
    integrations: IntegrationConnection;
    /** Retrieves information for the public invite page. */
    inviteInfo: InvitePagePayload;
    /** One specific issue. */
    issue: Issue;
    /** Fetches the GitHub token, completing the OAuth flow. */
    issueImportFinishGithubOAuth: OAuthTokenPayload;
    /** One specific label. */
    issueLabel: IssueLabel;
    /** All issue labels. */
    issueLabels: IssueLabelConnection;
    /** Issue priority values and corresponding labels. */
    issuePriorityValues: Array<IssuePriorityValue>;
    /** One specific issue relation. */
    issueRelation: IssueRelation;
    /** All issue relationships. */
    issueRelations: IssueRelationConnection;
    /** [ALPHA] Search issues. This query is experimental and is subject to change without notice. */
    issueSearch: IssueConnection;
    /** All issues. */
    issues: IssueConnection;
    /** One specific milestone. */
    milestone: Milestone;
    /** All milestones. */
    milestones: MilestoneConnection;
    /** One specific notification. */
    notification: Notification;
    /** One specific notification subscription. */
    notificationSubscription: NotificationSubscription;
    /** The user's notification subscriptions. */
    notificationSubscriptions: NotificationSubscriptionConnection;
    /** All notifications. */
    notifications: NotificationConnection;
    /** The user's organization. */
    organization: Organization;
    /** Does the organization exist. */
    organizationExists: OrganizationExistsPayload;
    /** One specific organization invite. */
    organizationInvite: IssueLabel;
    /** All invites for the organization. */
    organizationInvites: OrganizationInviteConnection;
    /** One specific project. */
    project: Project;
    /** One specific project link. */
    projectLink: ProjectLink;
    /** All links for the project. */
    projectLinks: ProjectLinkConnection;
    /** All projects. */
    projects: ProjectConnection;
    /** Sends a test push message. */
    pushSubscriptionTest: PushSubscriptionPayload;
    /** A specific reaction. */
    reaction: Reaction;
    /** All comment emoji reactions. */
    reactions: ReactionConnection;
    /** Fetch SSO login URL for the email provided. */
    ssoUrlFromEmail: SsoUrlFromEmailResponse;
    /** The organization's subscription. */
    subscription?: Maybe<Subscription>;
    /** Fetch data to catch up the client to the state of the world. */
    syncBootstrap: SyncResponse;
    /** One specific team. */
    team: Team;
    /** One specific team membership. */
    teamMembership: TeamMembership;
    /** All team memberships. */
    teamMemberships: TeamMembershipConnection;
    /** All teams. */
    teams: TeamConnection;
    /** A specific template. */
    template: Template;
    /** All templates from all users. */
    templates: Array<Template>;
    /** One specific user. */
    user: User;
    /** The user's settings. */
    userSettings: UserSettings;
    /** All users for the organization. */
    users: UserConnection;
    /** The currently authenticated user. */
    viewer: User;
    /** A specific webhook. */
    webhook: Webhook;
    /** All webhooks. */
    webhooks: WebhookConnection;
    /** One specific state. */
    workflowState: WorkflowState;
    /** All issue workflow states. */
    workflowStates: WorkflowStateConnection;
};
export declare type QueryApiKeysArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryApplicationWithAuthorizationArgs = {
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]>;
};
export declare type QueryArchivedModelSyncArgs = {
    identifier: Scalars["String"];
    modelClass: Scalars["String"];
};
export declare type QueryArchivedModelsSyncArgs = {
    before?: Maybe<Scalars["DateTime"]>;
    last?: Maybe<Scalars["Int"]>;
    modelClass: Scalars["String"];
    teamId: Scalars["String"];
    trashOption?: Maybe<TrashOptionType>;
};
export declare type QueryAttachmentArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCollaborativeDocumentJoinArgs = {
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
};
export declare type QueryCommentArgs = {
    id: Scalars["String"];
};
export declare type QueryCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCustomViewArgs = {
    id: Scalars["String"];
};
export declare type QueryCustomViewsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCycleArgs = {
    id: Scalars["String"];
};
export declare type QueryCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryEmojiArgs = {
    id: Scalars["String"];
};
export declare type QueryEmojisArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFavoriteArgs = {
    id: Scalars["String"];
};
export declare type QueryFavoritesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFigmaEmbedInfoArgs = {
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
};
export declare type QueryIntegrationArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationResourceArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationResourcesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryInviteInfoArgs = {
    teamHash?: Maybe<Scalars["String"]>;
    userHash: Scalars["String"];
};
export declare type QueryIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueImportFinishGithubOAuthArgs = {
    code: Scalars["String"];
};
export declare type QueryIssueLabelArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueRelationArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueSearchArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query: Scalars["String"];
};
export declare type QueryIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryMilestoneArgs = {
    id: Scalars["String"];
};
export declare type QueryMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryOrganizationExistsArgs = {
    urlKey: Scalars["String"];
};
export declare type QueryOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationInvitesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectLinkArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryReactionArgs = {
    id: Scalars["String"];
};
export declare type QueryReactionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QuerySsoUrlFromEmailArgs = {
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
};
export declare type QuerySyncBootstrapArgs = {
    databaseVersion?: Maybe<Scalars["Int"]>;
    sinceSyncId?: Maybe<Scalars["Int"]>;
    syncGroups?: Maybe<Array<Scalars["String"]>>;
};
export declare type QueryTeamArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTemplateArgs = {
    id: Scalars["String"];
};
export declare type QueryUserArgs = {
    id: Scalars["String"];
};
export declare type QueryUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWebhookArgs = {
    id: Scalars["String"];
};
export declare type QueryWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWorkflowStateArgs = {
    id: Scalars["String"];
};
export declare type QueryWorkflowStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A reaction associated with a comment. */
export declare type Reaction = Node & {
    __typename?: "Reaction";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment that the reaction is associated with. */
    comment: Comment;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Name of the reaction's emoji. */
    emoji: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who reacted. */
    user: User;
};
export declare type ReactionConnection = {
    __typename?: "ReactionConnection";
    edges: Array<ReactionEdge>;
    nodes: Array<Reaction>;
    pageInfo: PageInfo;
};
export declare type ReactionCreateInput = {
    /** The comment to associate the reaction with. */
    commentId: Scalars["String"];
    /** The emoji the user reacted with. */
    emoji?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one */
    id?: Maybe<Scalars["String"]>;
};
export declare type ReactionEdge = {
    __typename?: "ReactionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Reaction;
};
export declare type ReactionPayload = {
    __typename?: "ReactionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    reaction: Reaction;
    success: Scalars["Boolean"];
};
export declare type RotateSecretPayload = {
    __typename?: "RotateSecretPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The integration resource's settings */
export declare type SamlConfiguration = {
    __typename?: "SamlConfiguration";
    /** List of allowed email domains for SAML authentication. */
    allowedDomains?: Maybe<Array<Scalars["String"]>>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
export declare type SamlConfigurationInput = {
    /** List of allowed email domains for SAML authentication. */
    allowedDomains?: Maybe<Array<Scalars["String"]>>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
/** Sentry issue data */
export declare type SentryIssuePayload = {
    __typename?: "SentryIssuePayload";
    /** The Sentry identifier of the actor who created the issue. */
    actorId: Scalars["Float"];
    /** The name of the Sentry actor who created this issue. */
    actorName: Scalars["String"];
    /** The type of the actor who created the issue. */
    actorType: Scalars["String"];
    /** The date this issue was first seen. */
    firstSeen: Scalars["String"];
    /** The name of the first release version this issue appeared on, if available. */
    firstVersion?: Maybe<Scalars["String"]>;
    /** The Sentry identifier for the issue. */
    issueId: Scalars["String"];
    /** The title of the issue. */
    issueTitle: Scalars["String"];
    /** The Sentry identifier of the project this issue belongs to. */
    projectId: Scalars["Float"];
    /** The slug of the project this issue belongs to. */
    projectSlug: Scalars["String"];
    /** The shortId of the issue. */
    shortId: Scalars["String"];
    /** The description of the issue. */
    webUrl: Scalars["String"];
};
/** Sentry specific settings. */
export declare type SentrySettings = {
    __typename?: "SentrySettings";
    /** The slug of the Sentry organization being connected. */
    organizationSlug: Scalars["String"];
};
/** Slack notification specific settings. */
export declare type SlackPostSettings = {
    __typename?: "SlackPostSettings";
    channel: Scalars["String"];
    channelId: Scalars["String"];
    configurationUrl: Scalars["String"];
};
export declare type SsoUrlFromEmailResponse = {
    __typename?: "SsoUrlFromEmailResponse";
    /** SAML SSO sign-in URL. */
    samlSsoUrl: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type StepsResponse = {
    __typename?: "StepsResponse";
    /** List of client IDs for the document steps. */
    clientIds: Array<Scalars["String"]>;
    /** New document steps from the client. */
    steps?: Maybe<Array<Scalars["JSON"]>>;
    /** Client's document version. */
    version: Scalars["Int"];
};
/** The subscription of an organization. */
export declare type Subscription = Node & {
    __typename?: "Subscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The date the subscription was canceled, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The creator of the subscription. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The organization that the subscription is associated with. */
    organization: Organization;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: Maybe<Scalars["String"]>;
    /** The number of seats in the subscription. */
    seats: Scalars["Float"];
    /** The subscription type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type SubscriptionPayload = {
    __typename?: "SubscriptionPayload";
    /** The date the subscription was set to cancel at the end of the billing period, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The subscription entity being mutated. */
    subscription: Subscription;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type SubscriptionSessionPayload = {
    __typename?: "SubscriptionSessionPayload";
    /** The subscription session that was created or updated. */
    session?: Maybe<Scalars["String"]>;
};
export declare type SubscriptionUpdateInput = {
    /** The date the subscription was set to cancel, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: Maybe<Scalars["String"]>;
};
/**
 * Contains either the full serialized state of the application or delta packets that the requester can
 *   apply to the local data set in order to be up-to-date.
 */
export declare type SyncResponse = {
    __typename?: "SyncResponse";
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /**
     * JSON serialized delta changes that the client can apply to its local state
     *     in order to catch up with the state of the world.
     */
    delta?: Maybe<Scalars["String"]>;
    /** The last sync id covered by the response. */
    lastSyncId: Scalars["Float"];
    /**
     * The full state of the organization as a serialized JSON object.
     *     Mutually exclusive with the delta property
     */
    state?: Maybe<Scalars["String"]>;
    /** The sync groups that the user is subscribed to. */
    subscribedSyncGroups: Array<Scalars["String"]>;
};
export declare type SynchronizedPayload = {
    __typename?: "SynchronizedPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
};
/** An organizational unit that contains issues. */
export declare type Team = Node & {
    __typename?: "Team";
    /** Team's currently active cycle. */
    activeCycle?: Maybe<Cycle>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Period after which automatically closed and completed issues are automatically archived in months. Null/undefined means disabled. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Calender feed (iCal) for cycles. */
    cycleCalenderUrl: Scalars["String"];
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime: Scalars["Float"];
    /** The duration of a cycle in weeks. */
    cycleDuration: Scalars["Float"];
    /** Auto assign completed issues to current cycle. */
    cycleIssueAutoAssignCompleted: Scalars["Boolean"];
    /** Auto assign started issues to current cycle. */
    cycleIssueAutoAssignStarted: Scalars["Boolean"];
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive: Scalars["Boolean"];
    /** The day of the week that a new cycle starts. */
    cycleStartDay: Scalars["Float"];
    /** Cycles associated with the team. */
    cycles: CycleConnection;
    /** Whether the team uses cycles. */
    cyclesEnabled: Scalars["Boolean"];
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate: Scalars["Float"];
    /** The default template to use for new issues created by members of the team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The default template to use for new issues created by non-members of the team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The team's description. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been opened as draft. */
    draftWorkflowState?: Maybe<WorkflowState>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Unique hash for the team to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero: Scalars["Boolean"];
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended: Scalars["Boolean"];
    /** The issue estimation type to use. */
    issueEstimationType: Scalars["String"];
    /** Issues associated with the team. */
    issues: IssueConnection;
    /** The team's unique key. The key is used in URLs. */
    key: Scalars["String"];
    /** Labels associated with the team. */
    labels: IssueLabelConnection;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
    markedAsDuplicateWorkflowState?: Maybe<WorkflowState>;
    /** Users who are members of this team. */
    members: UserConnection;
    /** Memberships associated with the team. For easier access of the same data, use `members` query. */
    memberships: TeamMembershipConnection;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowState?: Maybe<WorkflowState>;
    /** The team's name. */
    name: Scalars["String"];
    /** The organization that the team is associated with. */
    organization: Organization;
    /** Internal. Whether the team is private or not. */
    private: Scalars["Boolean"];
    /** Projects associated with the team. */
    projects: ProjectConnection;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowState?: Maybe<WorkflowState>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowState?: Maybe<WorkflowState>;
    /** The states that define the workflow associated with the team. */
    states: WorkflowStateConnection;
    /** Templates associated with the team. */
    templates: TemplateConnection;
    /** The timezone of the team. Defaults to "America/Los_Angeles" */
    timezone: Scalars["String"];
    /** How many upcoming cycles to create. */
    upcomingCycleCount: Scalars["Float"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhooks associated with the team. */
    webhooks: WebhookConnection;
};
/** An organizational unit that contains issues. */
export declare type TeamCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type TeamConnection = {
    __typename?: "TeamConnection";
    edges: Array<TeamEdge>;
    nodes: Array<Team>;
    pageInfo: PageInfo;
};
export declare type TeamCreateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. 0 means disabled. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** The key of the team. If not given, rc key will be generated based on the name of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name: Scalars["String"];
    /** The organization associated with the team. */
    organizationId?: Maybe<Scalars["String"]>;
    /** Internal. Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
export declare type TeamEdge = {
    __typename?: "TeamEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Team;
};
/** Defines the membership of a user to a team. */
export declare type TeamMembership = Node & {
    __typename?: "TeamMembership";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Whether the user is the owner of the team */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The team that the membership is associated with. */
    team: Team;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that the membership is associated with. */
    user: User;
};
export declare type TeamMembershipConnection = {
    __typename?: "TeamMembershipConnection";
    edges: Array<TeamMembershipEdge>;
    nodes: Array<TeamMembership>;
    pageInfo: PageInfo;
};
export declare type TeamMembershipCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Internal. Whether the user is the owner of the team. */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The identifier of the team associated with the membership. */
    teamId: Scalars["String"];
    /** The identifier of the user associated with the membership. */
    userId: Scalars["String"];
};
export declare type TeamMembershipEdge = {
    __typename?: "TeamMembershipEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: TeamMembership;
};
export declare type TeamMembershipPayload = {
    __typename?: "TeamMembershipPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team membership that was created or updated. */
    teamMembership?: Maybe<TeamMembership>;
};
export declare type TeamMembershipUpdateInput = {
    /** Internal. Whether the user is the owner of the team. */
    owner: Scalars["Boolean"];
};
export declare type TeamPayload = {
    __typename?: "TeamPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team that was created or updated. */
    team?: Maybe<Team>;
};
export declare type TeamUpdateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a draft PR has been opened. */
    draftWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** The key of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name?: Maybe<Scalars["String"]>;
    /** Internal. Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
/** A template object used for creating new issues faster. */
export declare type Template = Node & {
    __typename?: "Template";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the template. */
    creator?: Maybe<User>;
    /** Template description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the template. */
    name: Scalars["String"];
    /** The team that the template is associated with. */
    team: Team;
    /** Template data. */
    templateData: Scalars["JSON"];
    /** The entity type this template is for. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type TemplateConnection = {
    __typename?: "TemplateConnection";
    edges: Array<TemplateEdge>;
    nodes: Array<Template>;
    pageInfo: PageInfo;
};
export declare type TemplateCreateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The template name. */
    name: Scalars["String"];
    /** The identifier or key of the team associated with the template. */
    teamId: Scalars["String"];
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData: Scalars["JSON"];
    /** The template type, e.g. 'issue'. */
    type: Scalars["String"];
};
export declare type TemplateEdge = {
    __typename?: "TemplateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Template;
};
export declare type TemplatePayload = {
    __typename?: "TemplatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The template that was created or updated. */
    template: Template;
};
export declare type TemplateUpdateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The template name. */
    name?: Maybe<Scalars["String"]>;
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData?: Maybe<Scalars["JSON"]>;
};
export declare type TokenUserAccountAuthInput = {
    /** The email which to login via the magic login code. */
    email: Scalars["String"];
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
    /** The magic login code. */
    token: Scalars["String"];
};
/** How trashed issues should be loaded. */
export declare enum TrashOptionType {
    ExcludeTrash = "excludeTrash",
    IncludeTrash = "includeTrash",
    TrashOnly = "trashOnly"
}
export declare type UpdateOrganizationInput = {
    /** List of services that are allowed to be used for login. */
    allowedAuthServices?: Maybe<Array<Scalars["String"]>>;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent for private repositories. */
    gitLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Whether the Git integration linkback messages should be sent for public repositories. */
    gitPublicLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Linear Preview feature flags */
    linearPreviewFlags?: Maybe<Scalars["JSONObject"]>;
    /** The logo of the organization. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** The name of the organization. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the organization is using project milestones. */
    roadmapEnabled?: Maybe<Scalars["Boolean"]>;
    /** The URL key of the organization. */
    urlKey?: Maybe<Scalars["String"]>;
};
export declare type UpdateUserInput = {
    /** Whether the user account is active. */
    active?: Maybe<Scalars["Boolean"]>;
    /** Whether the user account has admin privileges. */
    admin?: Maybe<Scalars["Boolean"]>;
    /** The avatar image URL of the user. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** Reason for deactivation. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The display name of the user. */
    displayName?: Maybe<Scalars["String"]>;
    /** The name of the user. */
    name?: Maybe<Scalars["String"]>;
};
/** Object representing Google Cloud upload policy, plus additional data. */
export declare type UploadFile = {
    __typename?: "UploadFile";
    /** The asset URL for the uploaded file. (assigned automatically) */
    assetUrl: Scalars["String"];
    /** The content type. */
    contentType: Scalars["String"];
    /** The filename. */
    filename: Scalars["String"];
    headers: Array<UploadFileHeader>;
    metaData?: Maybe<Scalars["JSON"]>;
    /** The size of the uploaded file. */
    size: Scalars["Int"];
    /** The signed URL the for the uploaded file. (assigned automatically) */
    uploadUrl: Scalars["String"];
};
export declare type UploadFileHeader = {
    __typename?: "UploadFileHeader";
    /** Upload file header key. */
    key: Scalars["String"];
    /** Upload file header value. */
    value: Scalars["String"];
};
export declare type UploadPayload = {
    __typename?: "UploadPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** Object describing the file to be uploaded. */
    uploadFile?: Maybe<UploadFile>;
};
/** A user that has access to the the resources of an organization. */
export declare type User = Node & {
    __typename?: "User";
    /** Whether the user account is active or disabled. */
    active: Scalars["Boolean"];
    /** Whether the user is an organization administrator. */
    admin: Scalars["Boolean"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Issues assigned to the user. */
    assignedIssues: IssueConnection;
    /** An URL to the user's avatar image. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues created. */
    createdIssueCount: Scalars["Int"];
    /** Issues created by the user. */
    createdIssues: IssueConnection;
    /** Reason why is the account disabled. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The user's display (nick) name. Unique within each organization. */
    displayName: Scalars["String"];
    /** The user's email address. */
    email: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Unique hash for the user to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** The last time the user was seen online. If null, the user is currently online. */
    lastSeen?: Maybe<Scalars["DateTime"]>;
    /** The user's full name. */
    name: Scalars["String"];
    /** Organization in which the user belongs to. */
    organization: Organization;
    /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
    teamMemberships: TeamMembershipConnection;
    /** Teams the user is part of. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A user that has access to the the resources of an organization. */
export declare type UserAssignedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserCreatedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user account. */
export declare type UserAccount = {
    __typename?: "UserAccount";
    /** The time at which the model was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the model was created. */
    createdAt: Scalars["DateTime"];
    /** The user's email address. */
    email: Scalars["String"];
    /** The models identifier. */
    id: Scalars["ID"];
    /** The user's name. */
    name?: Maybe<Scalars["String"]>;
    /** The authentication service used to create the account. */
    service: Scalars["String"];
    /** The time at which the model was updated. */
    updatedAt: Scalars["DateTime"];
    /** Users belonging to the account. */
    users: Array<User>;
};
export declare type UserAdminPayload = {
    __typename?: "UserAdminPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application, plus whether the application has been authorized for the given scopes. */
export declare type UserAuthorizedApplication = {
    __typename?: "UserAuthorizedApplication";
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Whether the user has authorized the application for the given scopes. */
    isAuthorized: Scalars["Boolean"];
    /** Application name. */
    name: Scalars["String"];
};
export declare type UserConnection = {
    __typename?: "UserConnection";
    edges: Array<UserEdge>;
    nodes: Array<User>;
    pageInfo: PageInfo;
};
export declare type UserEdge = {
    __typename?: "UserEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: User;
};
/** The types of flags that the user can have. */
export declare enum UserFlagType {
    AnalyticsWelcomeDismissed = "analyticsWelcomeDismissed",
    CanPlaySnake = "canPlaySnake",
    CompletedOnboarding = "completedOnboarding",
    CycleWelcomeDismissed = "cycleWelcomeDismissed",
    DesktopDownloadToastDismissed = "desktopDownloadToastDismissed",
    DesktopInstalled = "desktopInstalled",
    EmptyActiveIssuesDismissed = "emptyActiveIssuesDismissed",
    EmptyBacklogDismissed = "emptyBacklogDismissed",
    EmptyCustomViewsDismissed = "emptyCustomViewsDismissed",
    EmptyMyIssuesDismissed = "emptyMyIssuesDismissed",
    FigmaPromptDismissed = "figmaPromptDismissed",
    ListSelectionTip = "listSelectionTip",
    MigrateThemePreference = "migrateThemePreference",
    ProjectWelcomeDismissed = "projectWelcomeDismissed"
}
/** Operations that can be applied to UserFlagType */
export declare enum UserFlagUpdateOperation {
    Clear = "clear",
    Decr = "decr",
    Incr = "incr",
    Lock = "lock"
}
export declare type UserPayload = {
    __typename?: "UserPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user that was created or updated. */
    user?: Maybe<User>;
};
/** The settings of a user as a JSON object. */
export declare type UserSettings = Node & {
    __typename?: "UserSettings";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The notification channel settings the user has selected. */
    notificationPreferences: Scalars["JSONObject"];
    /** The email types the user has unsubscribed from. */
    unsubscribedFrom: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user associated with these settings. */
    user: User;
};
export declare type UserSettingsFlagPayload = {
    __typename?: "UserSettingsFlagPayload";
    /** The flag key which was updated. */
    flag: Scalars["String"];
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The flag value after update. */
    value: Scalars["Int"];
};
export declare type UserSettingsFlagsResetPayload = {
    __typename?: "UserSettingsFlagsResetPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type UserSettingsPayload = {
    __typename?: "UserSettingsPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user's settings. */
    userSettings: UserSettings;
};
export declare type UserSettingsUpdateInput = {
    /** The user's notification preferences. */
    notificationPreferences?: Maybe<Scalars["JSONObject"]>;
    /** The user's settings. */
    settings?: Maybe<Scalars["String"]>;
    /** The types of emails the user has unsubscribed from. */
    unsubscribedFrom?: Maybe<Array<Scalars["String"]>>;
};
export declare type UserSubscribeToNewsletterPayload = {
    __typename?: "UserSubscribeToNewsletterPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** View preferences. */
export declare type ViewPreferences = Node & {
    __typename?: "ViewPreferences";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The view preference type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The view type. */
    viewType: Scalars["String"];
};
export declare type ViewPreferencesCreateInput = {
    /** The custom view these view preferences are associated with. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The cycle these view preferences are associated with. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The label these view preferences are associated with. */
    labelId?: Maybe<Scalars["String"]>;
    /** View preferences object. */
    preferences: Scalars["JSONObject"];
    /** The project these view preferences are associated with. */
    projectId?: Maybe<Scalars["String"]>;
    /** The team these view preferences are associated with. */
    teamId?: Maybe<Scalars["String"]>;
    /** The type of view preferences (either user or organization level preferences). */
    type: ViewPreferencesType;
    /** The view type of the view preferences are associated with. */
    viewType: ViewType;
};
export declare type ViewPreferencesPayload = {
    __typename?: "ViewPreferencesPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The view preferences entity being mutated. */
    viewPreferences: ViewPreferences;
};
/** The type of view preferences (either user or organization level preferences). */
export declare enum ViewPreferencesType {
    Organization = "organization",
    User = "user"
}
export declare type ViewPreferencesUpdateInput = {
    /** View preferences. */
    preferences: Scalars["JSONObject"];
};
/** The client view this custom view is targeting. */
export declare enum ViewType {
    ActiveIssues = "activeIssues",
    AllIssues = "allIssues",
    Backlog = "backlog",
    Board = "board",
    CompletedCycle = "completedCycle",
    CustomView = "customView",
    Cycle = "cycle",
    Inbox = "inbox",
    Label = "label",
    MyIssues = "myIssues",
    Project = "project",
    Projects = "projects",
    Roadmap = "roadmap"
}
/** A webhook used to send HTTP notifications over data updates */
export declare type Webhook = Node & {
    __typename?: "Webhook";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the webhook. */
    creator?: Maybe<User>;
    /** Whether the Webhook is enabled. */
    enabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Webhook label */
    label: Scalars["String"];
    /** The resource types this webhook is subscribed to. */
    resourceTypes: Array<Scalars["String"]>;
    /** Secret token for verifying the origin on the recipient side. */
    secret?: Maybe<Scalars["String"]>;
    /** The team that the webhook is associated with. */
    team: Team;
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhook URL */
    url: Scalars["String"];
};
export declare type WebhookConnection = {
    __typename?: "WebhookConnection";
    edges: Array<WebhookEdge>;
    nodes: Array<Webhook>;
    pageInfo: PageInfo;
};
export declare type WebhookCreateInput = {
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes: Array<Scalars["String"]>;
    /** An optional secret token used to sign the webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The identifier or key of the team associated with the Webhook. */
    teamId: Scalars["String"];
    /** The URL that will be called on data changes. */
    url: Scalars["String"];
};
export declare type WebhookEdge = {
    __typename?: "WebhookEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Webhook;
};
export declare type WebhookPayload = {
    __typename?: "WebhookPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The webhook entity being mutated. */
    webhook: Webhook;
};
export declare type WebhookUpdateInput = {
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes?: Maybe<Array<Scalars["String"]>>;
    /** An optional secret token used to sign the Webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    url?: Maybe<Scalars["String"]>;
};
/** A state in a team workflow. */
export declare type WorkflowState = Node & {
    __typename?: "WorkflowState";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The state's UI color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issues belonging in this state. */
    issues: IssueConnection;
    /** The state's name. */
    name: Scalars["String"];
    /** The position of the state in the team flow. */
    position: Scalars["Float"];
    /** The team to which this state belongs to. */
    team: Team;
    /** The type of the state. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was updated. This is the same as the creation time if the
     *     entity hasn't been update after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A state in a team workflow. */
export declare type WorkflowStateIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type WorkflowStateConnection = {
    __typename?: "WorkflowStateConnection";
    edges: Array<WorkflowStateEdge>;
    nodes: Array<WorkflowState>;
    pageInfo: PageInfo;
};
export declare type WorkflowStateCreateInput = {
    /** The color of the state. */
    color: Scalars["String"];
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name: Scalars["String"];
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
    /** The team associated with the state. */
    teamId: Scalars["String"];
    /** The workflow type. */
    type: Scalars["String"];
};
export declare type WorkflowStateEdge = {
    __typename?: "WorkflowStateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: WorkflowState;
};
export declare type WorkflowStatePayload = {
    __typename?: "WorkflowStatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The state that was created or updated. */
    workflowState: WorkflowState;
};
export declare type WorkflowStateUpdateInput = {
    /** The color of the state. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name?: Maybe<Scalars["String"]>;
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
};
/** Zendesk specific settings. */
export declare type ZendeskSettings = {
    __typename?: "ZendeskSettings";
    /** The ID of the Linear bot user. */
    botUserId: Scalars["String"];
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: Scalars["String"];
    /** The URL of the connected Zendesk organization. */
    url: Scalars["String"];
};
export declare type CommentFragment = {
    __typename?: "Comment";
} & Pick<Comment, "url" | "body" | "updatedAt" | "archivedAt" | "createdAt" | "editedAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type EmojiFragment = {
    __typename?: "Emoji";
} & Pick<Emoji, "url" | "name" | "updatedAt" | "source" | "archivedAt" | "createdAt" | "id"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewFragment = {
    __typename?: "CustomView";
} & Pick<CustomView, "color" | "description" | "filters" | "icon" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id" | "shared"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type MilestoneFragment = {
    __typename?: "Milestone";
} & Pick<Milestone, "updatedAt" | "name" | "sortOrder" | "archivedAt" | "createdAt" | "id">;
export declare type NotificationFragment = {
    __typename?: "Notification";
} & Pick<Notification, "reactionEmoji" | "type" | "updatedAt" | "emailedAt" | "readAt" | "archivedAt" | "createdAt" | "id"> & {
    comment?: Maybe<{
        __typename?: "Comment";
    } & Pick<Comment, "id">>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type ProjectFragment = {
    __typename?: "Project";
} & Pick<Project, "targetDate" | "icon" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "color" | "description" | "name" | "slugId" | "sortOrder" | "archivedAt" | "createdAt" | "canceledAt" | "completedAt" | "startedAt" | "scopeHistory" | "issueCountHistory" | "state" | "id" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses"> & {
    milestone?: Maybe<{
        __typename?: "Milestone";
    } & Pick<Milestone, "id">>;
    lead?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ReactionFragment = {
    __typename?: "Reaction";
} & Pick<Reaction, "emoji" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    comment: {
        __typename?: "Comment";
    } & Pick<Comment, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueHistoryFragment = {
    __typename?: "IssueHistory";
} & Pick<IssueHistory, "relationChanges" | "addedLabelIds" | "removedLabelIds" | "source" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "fromDueDate" | "toDueDate" | "fromEstimate" | "toEstimate" | "fromPriority" | "toPriority" | "fromTitle" | "toTitle" | "archived" | "updatedDescription" | "autoArchived" | "autoClosed"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    toCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    toParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    toProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    toState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    fromParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    fromProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    fromState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    toTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    fromAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    toAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type FileUploadFragment = {
    __typename?: "FileUpload";
} & Pick<FileUpload, "metaData" | "size" | "contentType" | "assetUrl" | "filename" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueRelationFragment = {
    __typename?: "IssueRelation";
} & Pick<IssueRelation, "updatedAt" | "type" | "archivedAt" | "createdAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    relatedIssue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type CycleFragment = {
    __typename?: "Cycle";
} & Pick<Cycle, "completedAt" | "name" | "endsAt" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "number" | "startsAt" | "archivedAt" | "createdAt" | "scopeHistory" | "issueCountHistory" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type WorkflowStateFragment = {
    __typename?: "WorkflowState";
} & Pick<WorkflowState, "description" | "updatedAt" | "position" | "color" | "name" | "archivedAt" | "createdAt" | "type" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type TemplateFragment = {
    __typename?: "Template";
} & Pick<Template, "templateData" | "description" | "type" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserAccountFragment = {
    __typename?: "UserAccount";
} & Pick<UserAccount, "service" | "id" | "archivedAt" | "createdAt" | "updatedAt" | "email" | "name"> & {
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type UserFragment = {
    __typename?: "User";
} & Pick<User, "avatarUrl" | "createdIssueCount" | "disableReason" | "updatedAt" | "lastSeen" | "archivedAt" | "createdAt" | "id" | "displayName" | "email" | "name" | "inviteHash" | "active" | "admin">;
export declare type PushSubscriptionFragment = {
    __typename?: "PushSubscription";
} & Pick<PushSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type WebhookFragment = {
    __typename?: "Webhook";
} & Pick<Webhook, "secret" | "updatedAt" | "resourceTypes" | "archivedAt" | "createdAt" | "id" | "url" | "label" | "enabled"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ApiKeyFragment = {
    __typename?: "ApiKey";
} & Pick<ApiKey, "label" | "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type ProjectLinkFragment = {
    __typename?: "ProjectLink";
} & Pick<ProjectLink, "updatedAt" | "url" | "label" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueImportFragment = {
    __typename?: "IssueImport";
} & Pick<IssueImport, "creatorId" | "updatedAt" | "service" | "status" | "archivedAt" | "createdAt" | "id" | "error">;
export declare type IntegrationResourceFragment = {
    __typename?: "IntegrationResource";
} & Pick<IntegrationResource, "resourceId" | "resourceType" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    data: {
        __typename?: "IntegrationResourceData";
    } & IntegrationResourceDataFragment;
    pullRequest: {
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment;
    integration: {
        __typename?: "Integration";
    } & Pick<Integration, "id">;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type IntegrationFragment = {
    __typename?: "Integration";
} & Pick<Integration, "service" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationInviteFragment = {
    __typename?: "OrganizationInvite";
} & Pick<OrganizationInvite, "external" | "email" | "updatedAt" | "archivedAt" | "createdAt" | "acceptedAt" | "expiresAt" | "id"> & {
    inviter: {
        __typename?: "User";
    } & Pick<User, "id">;
    invitee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueFragment = {
    __typename?: "Issue";
} & Pick<Issue, "trashed" | "url" | "identifier" | "priorityLabel" | "previousIdentifiers" | "branchName" | "dueDate" | "estimate" | "description" | "title" | "number" | "updatedAt" | "boardOrder" | "subIssueSortOrder" | "priority" | "archivedAt" | "createdAt" | "autoArchivedAt" | "autoClosedAt" | "canceledAt" | "completedAt" | "startedAt" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    parent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    assignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    state: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type OrganizationFragment = {
    __typename?: "Organization";
} & Pick<Organization, "allowedAuthServices" | "gitBranchFormat" | "userCount" | "createdIssueCount" | "periodUploadVolume" | "updatedAt" | "logoUrl" | "name" | "urlKey" | "archivedAt" | "createdAt" | "id" | "samlEnabled" | "gitLinkbackMessagesEnabled" | "gitPublicLinkbackMessagesEnabled" | "roadmapEnabled">;
export declare type TeamFragment = {
    __typename?: "Team";
} & Pick<Team, "cycleIssueAutoAssignCompleted" | "cycleIssueAutoAssignStarted" | "cycleCalenderUrl" | "upcomingCycleCount" | "private" | "cycleLockToActive" | "autoArchivePeriod" | "autoClosePeriod" | "autoCloseStateId" | "cycleCooldownTime" | "cycleStartDay" | "defaultTemplateForMembersId" | "defaultTemplateForNonMembersId" | "cycleDuration" | "issueEstimationType" | "updatedAt" | "description" | "name" | "key" | "archivedAt" | "createdAt" | "timezone" | "id" | "inviteHash" | "defaultIssueEstimate" | "cyclesEnabled" | "issueEstimationExtended" | "issueEstimationAllowZero" | "groupIssueHistory" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses"> & {
    activeCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    mergeWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    draftWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    startWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    reviewWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    markedAsDuplicateWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
};
export declare type DocumentStepFragment = {
    __typename?: "DocumentStep";
} & Pick<DocumentStep, "clientId" | "step" | "version" | "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type SyncResponseFragment = {
    __typename?: "SyncResponse";
} & Pick<SyncResponse, "delta" | "state" | "lastSyncId" | "subscribedSyncGroups" | "databaseVersion">;
export declare type ArchiveResponseFragment = {
    __typename?: "ArchiveResponse";
} & Pick<ArchiveResponse, "archive" | "totalCount" | "databaseVersion">;
export declare type TeamMembershipFragment = {
    __typename?: "TeamMembership";
} & Pick<TeamMembership, "updatedAt" | "archivedAt" | "createdAt" | "id" | "owner"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationDomainFragment = {
    __typename?: "OrganizationDomain";
} & Pick<OrganizationDomain, "name" | "verificationEmail" | "verified" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type OAuthTokenPayloadFragment = {
    __typename?: "OAuthTokenPayload";
} & Pick<OAuthTokenPayload, "token"> & {
    organizations?: Maybe<Array<{
        __typename?: "GithubOrg";
    } & GithubOrgFragment>>;
};
export declare type CommitPayloadFragment = {
    __typename?: "CommitPayload";
} & Pick<CommitPayload, "added" | "id" | "message" | "modified" | "removed" | "timestamp" | "url">;
export declare type GoogleSheetsSettingsFragment = {
    __typename?: "GoogleSheetsSettings";
} & Pick<GoogleSheetsSettings, "sheetId" | "spreadsheetId" | "spreadsheetUrl" | "updatedIssuesAt">;
export declare type IntegrationResourceDataFragment = {
    __typename?: "IntegrationResourceData";
} & {
    githubCommit?: Maybe<{
        __typename?: "CommitPayload";
    } & CommitPayloadFragment>;
    githubPullRequest?: Maybe<{
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment>;
    gitlabMergeRequest?: Maybe<{
        __typename?: "PullRequestPayload";
    } & PullRequestPayloadFragment>;
    sentryIssue?: Maybe<{
        __typename?: "SentryIssuePayload";
    } & SentryIssuePayloadFragment>;
};
export declare type IssueLabelFragment = {
    __typename?: "IssueLabel";
} & Pick<IssueLabel, "color" | "description" | "name" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type NotificationSubscriptionFragment = {
    __typename?: "NotificationSubscription";
} & Pick<NotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "type" | "id"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OauthClientFragment = {
    __typename?: "OauthClient";
} & Pick<OauthClient, "imageUrl" | "description" | "redirectUris" | "developer" | "clientId" | "name" | "clientSecret" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "developerUrl">;
export declare type FigmaEmbedFragment = {
    __typename?: "FigmaEmbed";
} & Pick<FigmaEmbed, "lastModified" | "name" | "url" | "nodeName">;
export declare type UploadFileFragment = {
    __typename?: "UploadFile";
} & Pick<UploadFile, "assetUrl" | "contentType" | "filename" | "uploadUrl" | "size" | "metaData"> & {
    headers: Array<{
        __typename?: "UploadFileHeader";
    } & UploadFileHeaderFragment>;
};
export declare type AuthorizedApplicationFragment = {
    __typename?: "AuthorizedApplication";
} & Pick<AuthorizedApplication, "name" | "imageUrl" | "description" | "developer" | "appId" | "clientId" | "scope" | "developerUrl">;
export declare type UserAuthorizedApplicationFragment = {
    __typename?: "UserAuthorizedApplication";
} & Pick<UserAuthorizedApplication, "name" | "imageUrl" | "description" | "developer" | "clientId" | "developerUrl" | "isAuthorized">;
export declare type ApplicationFragment = {
    __typename?: "Application";
} & Pick<Application, "name" | "imageUrl" | "description" | "developer" | "clientId" | "developerUrl">;
export declare type PullRequestPayloadFragment = {
    __typename?: "PullRequestPayload";
} & Pick<PullRequestPayload, "branch" | "closedAt" | "createdAt" | "draft" | "id" | "mergedAt" | "number" | "repoLogin" | "repoName" | "status" | "title" | "updatedAt" | "url" | "userId" | "userLogin">;
export declare type GithubOrgFragment = {
    __typename?: "GithubOrg";
} & Pick<GithubOrg, "id" | "login" | "name"> & {
    repositories: Array<{
        __typename?: "GithubRepo";
    } & GithubRepoFragment>;
};
export declare type GithubRepoFragment = {
    __typename?: "GithubRepo";
} & Pick<GithubRepo, "id" | "name">;
export declare type SentryIssuePayloadFragment = {
    __typename?: "SentryIssuePayload";
} & Pick<SentryIssuePayload, "issueId" | "actorId" | "projectId" | "firstSeen" | "webUrl" | "actorName" | "firstVersion" | "shortId" | "projectSlug" | "issueTitle" | "actorType">;
export declare type SentrySettingsFragment = {
    __typename?: "SentrySettings";
} & Pick<SentrySettings, "organizationSlug">;
export declare type SlackPostSettingsFragment = {
    __typename?: "SlackPostSettings";
} & Pick<SlackPostSettings, "channel" | "channelId" | "configurationUrl">;
export declare type IntegrationSettingsFragment = {
    __typename?: "IntegrationSettings";
} & {
    googleSheets?: Maybe<{
        __typename?: "GoogleSheetsSettings";
    } & GoogleSheetsSettingsFragment>;
    sentry?: Maybe<{
        __typename?: "SentrySettings";
    } & SentrySettingsFragment>;
    slackPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    slackProjectPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    zendesk?: Maybe<{
        __typename?: "ZendeskSettings";
    } & ZendeskSettingsFragment>;
};
export declare type SamlConfigurationFragment = {
    __typename?: "SamlConfiguration";
} & Pick<SamlConfiguration, "ssoBinding" | "allowedDomains" | "ssoEndpoint" | "ssoSignAlgo" | "ssoSigningCert">;
export declare type UserSettingsFragment = {
    __typename?: "UserSettings";
} & Pick<UserSettings, "unsubscribedFrom" | "updatedAt" | "notificationPreferences" | "archivedAt" | "createdAt" | "id"> & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type SubscriptionFragment = {
    __typename?: "Subscription";
} & Pick<Subscription, "canceledAt" | "updatedAt" | "seats" | "pendingChangeType" | "type" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type FavoriteFragment = {
    __typename?: "Favorite";
} & Pick<Favorite, "updatedAt" | "sortOrder" | "archivedAt" | "createdAt" | "type" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    projectTeam?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ViewPreferencesFragment = {
    __typename?: "ViewPreferences";
} & Pick<ViewPreferences, "updatedAt" | "archivedAt" | "createdAt" | "id" | "type" | "viewType">;
export declare type ZendeskSettingsFragment = {
    __typename?: "ZendeskSettings";
} & Pick<ZendeskSettings, "botUserId" | "url" | "subdomain">;
export declare type AttachmentFragment = {
    __typename?: "Attachment";
} & Pick<Attachment, "subtitle" | "title" | "metadata" | "groupBySource" | "source" | "url" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type ApiKeyConnectionFragment = {
    __typename?: "ApiKeyConnection";
} & {
    nodes: Array<{
        __typename?: "ApiKey";
    } & ApiKeyFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ApiKeyPayloadFragment = {
    __typename?: "ApiKeyPayload";
} & Pick<ApiKeyPayload, "lastSyncId" | "success"> & {
    apiKey: {
        __typename?: "ApiKey";
    } & ApiKeyFragment;
};
export declare type ArchivePayloadFragment = {
    __typename?: "ArchivePayload";
} & Pick<ArchivePayload, "lastSyncId" | "success">;
export declare type AttachmentConnectionFragment = {
    __typename?: "AttachmentConnection";
} & {
    nodes: Array<{
        __typename?: "Attachment";
    } & AttachmentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type AttachmentPayloadFragment = {
    __typename?: "AttachmentPayload";
} & Pick<AttachmentPayload, "lastSyncId" | "success"> & {
    attachment: {
        __typename?: "Attachment";
    } & Pick<Attachment, "id">;
};
export declare type AuthResolverResponseFragment = {
    __typename?: "AuthResolverResponse";
} & Pick<AuthResolverResponse, "email" | "token" | "allowDomainAccess" | "id"> & {
    availableOrganizations?: Maybe<Array<{
        __typename?: "Organization";
    } & OrganizationFragment>>;
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type BillingDetailsPayloadFragment = {
    __typename?: "BillingDetailsPayload";
} & Pick<BillingDetailsPayload, "email" | "success"> & {
    invoices: Array<{
        __typename?: "Invoice";
    } & InvoiceFragment>;
    paymentMethod?: Maybe<{
        __typename?: "Card";
    } & CardFragment>;
};
export declare type BillingEmailPayloadFragment = {
    __typename?: "BillingEmailPayload";
} & Pick<BillingEmailPayload, "email" | "success">;
export declare type CardFragment = {
    __typename?: "Card";
} & Pick<Card, "brand" | "last4">;
export declare type CollaborationDocumentUpdatePayloadFragment = {
    __typename?: "CollaborationDocumentUpdatePayload";
} & Pick<CollaborationDocumentUpdatePayload, "success"> & {
    steps?: Maybe<{
        __typename?: "StepsResponse";
    } & StepsResponseFragment>;
};
export declare type CommentConnectionFragment = {
    __typename?: "CommentConnection";
} & {
    nodes: Array<{
        __typename?: "Comment";
    } & CommentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CommentPayloadFragment = {
    __typename?: "CommentPayload";
} & Pick<CommentPayload, "lastSyncId" | "success"> & {
    comment: {
        __typename?: "Comment";
    } & Pick<Comment, "id">;
};
export declare type ContactPayloadFragment = {
    __typename?: "ContactPayload";
} & Pick<ContactPayload, "success">;
export declare type CreateCsvExportReportPayloadFragment = {
    __typename?: "CreateCsvExportReportPayload";
} & Pick<CreateCsvExportReportPayload, "success">;
export declare type CreateOrJoinOrganizationResponseFragment = {
    __typename?: "CreateOrJoinOrganizationResponse";
} & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewConnectionFragment = {
    __typename?: "CustomViewConnection";
} & {
    nodes: Array<{
        __typename?: "CustomView";
    } & CustomViewFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CustomViewPayloadFragment = {
    __typename?: "CustomViewPayload";
} & Pick<CustomViewPayload, "lastSyncId" | "success"> & {
    customView: {
        __typename?: "CustomView";
    } & Pick<CustomView, "id">;
};
export declare type CycleConnectionFragment = {
    __typename?: "CycleConnection";
} & {
    nodes: Array<{
        __typename?: "Cycle";
    } & CycleFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CyclePayloadFragment = {
    __typename?: "CyclePayload";
} & Pick<CyclePayload, "lastSyncId" | "success"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
};
export declare type DebugPayloadFragment = {
    __typename?: "DebugPayload";
} & Pick<DebugPayload, "success">;
export declare type EmailUnsubscribePayloadFragment = {
    __typename?: "EmailUnsubscribePayload";
} & Pick<EmailUnsubscribePayload, "success">;
export declare type EmailUserAccountAuthChallengeResponseFragment = {
    __typename?: "EmailUserAccountAuthChallengeResponse";
} & Pick<EmailUserAccountAuthChallengeResponse, "authType" | "success">;
export declare type EmojiConnectionFragment = {
    __typename?: "EmojiConnection";
} & {
    nodes: Array<{
        __typename?: "Emoji";
    } & EmojiFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type EmojiPayloadFragment = {
    __typename?: "EmojiPayload";
} & Pick<EmojiPayload, "lastSyncId" | "success"> & {
    emoji: {
        __typename?: "Emoji";
    } & Pick<Emoji, "id">;
};
export declare type EventPayloadFragment = {
    __typename?: "EventPayload";
} & Pick<EventPayload, "success">;
export declare type FavoriteConnectionFragment = {
    __typename?: "FavoriteConnection";
} & {
    nodes: Array<{
        __typename?: "Favorite";
    } & FavoriteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type FavoritePayloadFragment = {
    __typename?: "FavoritePayload";
} & Pick<FavoritePayload, "lastSyncId" | "success"> & {
    favorite: {
        __typename?: "Favorite";
    } & Pick<Favorite, "id">;
};
export declare type FeedbackPayloadFragment = {
    __typename?: "FeedbackPayload";
} & Pick<FeedbackPayload, "success">;
export declare type FigmaEmbedPayloadFragment = {
    __typename?: "FigmaEmbedPayload";
} & Pick<FigmaEmbedPayload, "success"> & {
    figmaEmbed?: Maybe<{
        __typename?: "FigmaEmbed";
    } & FigmaEmbedFragment>;
};
export declare type ImageUploadFromUrlPayloadFragment = {
    __typename?: "ImageUploadFromUrlPayload";
} & Pick<ImageUploadFromUrlPayload, "url" | "lastSyncId" | "success">;
export declare type IntegrationConnectionFragment = {
    __typename?: "IntegrationConnection";
} & {
    nodes: Array<{
        __typename?: "Integration";
    } & IntegrationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IntegrationPayloadFragment = {
    __typename?: "IntegrationPayload";
} & Pick<IntegrationPayload, "lastSyncId" | "success"> & {
    integration?: Maybe<{
        __typename?: "Integration";
    } & Pick<Integration, "id">>;
};
export declare type IntegrationResourceConnectionFragment = {
    __typename?: "IntegrationResourceConnection";
} & {
    nodes: Array<{
        __typename?: "IntegrationResource";
    } & IntegrationResourceFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type InviteDataFragment = {
    __typename?: "InviteData";
} & Pick<InviteData, "avatarURLs" | "teamIds" | "teamNames" | "organizationDomain" | "organizationLogoUrl" | "inviterName" | "organizationName" | "userCount">;
export declare type InvitePagePayloadFragment = {
    __typename?: "InvitePagePayload";
} & Pick<InvitePagePayload, "success"> & {
    inviteData?: Maybe<{
        __typename?: "InviteData";
    } & InviteDataFragment>;
};
export declare type InvoiceFragment = {
    __typename?: "Invoice";
} & Pick<Invoice, "url" | "created" | "dueDate" | "total" | "status">;
export declare type IssueConnectionFragment = {
    __typename?: "IssueConnection";
} & {
    nodes: Array<{
        __typename?: "Issue";
    } & IssueFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueHistoryConnectionFragment = {
    __typename?: "IssueHistoryConnection";
} & {
    nodes: Array<{
        __typename?: "IssueHistory";
    } & IssueHistoryFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueImportDeletePayloadFragment = {
    __typename?: "IssueImportDeletePayload";
} & Pick<IssueImportDeletePayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueImportPayloadFragment = {
    __typename?: "IssueImportPayload";
} & Pick<IssueImportPayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueLabelConnectionFragment = {
    __typename?: "IssueLabelConnection";
} & {
    nodes: Array<{
        __typename?: "IssueLabel";
    } & IssueLabelFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueLabelPayloadFragment = {
    __typename?: "IssueLabelPayload";
} & Pick<IssueLabelPayload, "lastSyncId" | "success"> & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">;
};
export declare type IssuePayloadFragment = {
    __typename?: "IssuePayload";
} & Pick<IssuePayload, "lastSyncId" | "success"> & {
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
};
export declare type IssuePriorityValueFragment = {
    __typename?: "IssuePriorityValue";
} & Pick<IssuePriorityValue, "label" | "priority">;
export declare type IssueRelationConnectionFragment = {
    __typename?: "IssueRelationConnection";
} & {
    nodes: Array<{
        __typename?: "IssueRelation";
    } & IssueRelationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueRelationPayloadFragment = {
    __typename?: "IssueRelationPayload";
} & Pick<IssueRelationPayload, "lastSyncId" | "success"> & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & Pick<IssueRelation, "id">;
};
export declare type MilestoneConnectionFragment = {
    __typename?: "MilestoneConnection";
} & {
    nodes: Array<{
        __typename?: "Milestone";
    } & MilestoneFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type MilestonePayloadFragment = {
    __typename?: "MilestonePayload";
} & Pick<MilestonePayload, "lastSyncId" | "success"> & {
    milestone?: Maybe<{
        __typename?: "Milestone";
    } & Pick<Milestone, "id">>;
};
export declare type NotificationConnectionFragment = {
    __typename?: "NotificationConnection";
} & {
    nodes: Array<{
        __typename?: "Notification";
    } & NotificationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationPayloadFragment = {
    __typename?: "NotificationPayload";
} & Pick<NotificationPayload, "lastSyncId" | "success"> & {
    notification: {
        __typename?: "Notification";
    } & Pick<Notification, "id">;
};
export declare type NotificationSubscriptionConnectionFragment = {
    __typename?: "NotificationSubscriptionConnection";
} & {
    nodes: Array<{
        __typename?: "NotificationSubscription";
    } & NotificationSubscriptionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationSubscriptionPayloadFragment = {
    __typename?: "NotificationSubscriptionPayload";
} & Pick<NotificationSubscriptionPayload, "lastSyncId" | "success"> & {
    notificationSubscription: {
        __typename?: "NotificationSubscription";
    } & Pick<NotificationSubscription, "id">;
};
export declare type OauthClientPayloadFragment = {
    __typename?: "OauthClientPayload";
} & Pick<OauthClientPayload, "lastSyncId" | "success"> & {
    oauthClient: {
        __typename?: "OauthClient";
    } & OauthClientFragment;
};
export declare type OauthTokenRevokePayloadFragment = {
    __typename?: "OauthTokenRevokePayload";
} & Pick<OauthTokenRevokePayload, "success">;
export declare type OrganizationDeletePayloadFragment = {
    __typename?: "OrganizationDeletePayload";
} & Pick<OrganizationDeletePayload, "success">;
export declare type OrganizationDomainPayloadFragment = {
    __typename?: "OrganizationDomainPayload";
} & Pick<OrganizationDomainPayload, "lastSyncId" | "success"> & {
    organizationDomain: {
        __typename?: "OrganizationDomain";
    } & OrganizationDomainFragment;
};
export declare type OrganizationDomainSimplePayloadFragment = {
    __typename?: "OrganizationDomainSimplePayload";
} & Pick<OrganizationDomainSimplePayload, "success">;
export declare type OrganizationExistsPayloadFragment = {
    __typename?: "OrganizationExistsPayload";
} & Pick<OrganizationExistsPayload, "success" | "exists">;
export declare type OrganizationInviteConnectionFragment = {
    __typename?: "OrganizationInviteConnection";
} & {
    nodes: Array<{
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type OrganizationInvitePayloadFragment = {
    __typename?: "OrganizationInvitePayload";
} & Pick<OrganizationInvitePayload, "lastSyncId" | "success"> & {
    organizationInvite: {
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment;
};
export declare type OrganizationPayloadFragment = {
    __typename?: "OrganizationPayload";
} & Pick<OrganizationPayload, "lastSyncId" | "success">;
export declare type PageInfoFragment = {
    __typename?: "PageInfo";
} & Pick<PageInfo, "startCursor" | "endCursor" | "hasPreviousPage" | "hasNextPage">;
export declare type ProjectConnectionFragment = {
    __typename?: "ProjectConnection";
} & {
    nodes: Array<{
        __typename?: "Project";
    } & ProjectFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectLinkConnectionFragment = {
    __typename?: "ProjectLinkConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectLink";
    } & ProjectLinkFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectLinkPayloadFragment = {
    __typename?: "ProjectLinkPayload";
} & Pick<ProjectLinkPayload, "lastSyncId" | "success"> & {
    projectLink: {
        __typename?: "ProjectLink";
    } & Pick<ProjectLink, "id">;
};
export declare type ProjectPayloadFragment = {
    __typename?: "ProjectPayload";
} & Pick<ProjectPayload, "lastSyncId" | "success"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
};
export declare type PushSubscriptionConnectionFragment = {
    __typename?: "PushSubscriptionConnection";
} & {
    nodes: Array<{
        __typename?: "PushSubscription";
    } & PushSubscriptionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type PushSubscriptionPayloadFragment = {
    __typename?: "PushSubscriptionPayload";
} & Pick<PushSubscriptionPayload, "lastSyncId" | "success">;
export declare type ReactionConnectionFragment = {
    __typename?: "ReactionConnection";
} & {
    nodes: Array<{
        __typename?: "Reaction";
    } & ReactionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ReactionPayloadFragment = {
    __typename?: "ReactionPayload";
} & Pick<ReactionPayload, "lastSyncId" | "success"> & {
    reaction: {
        __typename?: "Reaction";
    } & Pick<Reaction, "id">;
};
export declare type RotateSecretPayloadFragment = {
    __typename?: "RotateSecretPayload";
} & Pick<RotateSecretPayload, "lastSyncId" | "success">;
export declare type SsoUrlFromEmailResponseFragment = {
    __typename?: "SsoUrlFromEmailResponse";
} & Pick<SsoUrlFromEmailResponse, "samlSsoUrl" | "success">;
export declare type StepsResponseFragment = {
    __typename?: "StepsResponse";
} & Pick<StepsResponse, "version" | "clientIds" | "steps">;
export declare type SubscriptionPayloadFragment = {
    __typename?: "SubscriptionPayload";
} & Pick<SubscriptionPayload, "canceledAt" | "lastSyncId" | "success">;
export declare type SubscriptionSessionPayloadFragment = {
    __typename?: "SubscriptionSessionPayload";
} & Pick<SubscriptionSessionPayload, "session">;
export declare type SynchronizedPayloadFragment = {
    __typename?: "SynchronizedPayload";
} & Pick<SynchronizedPayload, "lastSyncId">;
export declare type TeamConnectionFragment = {
    __typename?: "TeamConnection";
} & {
    nodes: Array<{
        __typename?: "Team";
    } & TeamFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipConnectionFragment = {
    __typename?: "TeamMembershipConnection";
} & {
    nodes: Array<{
        __typename?: "TeamMembership";
    } & TeamMembershipFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipPayloadFragment = {
    __typename?: "TeamMembershipPayload";
} & Pick<TeamMembershipPayload, "lastSyncId" | "success"> & {
    teamMembership?: Maybe<{
        __typename?: "TeamMembership";
    } & Pick<TeamMembership, "id">>;
};
export declare type TeamPayloadFragment = {
    __typename?: "TeamPayload";
} & Pick<TeamPayload, "lastSyncId" | "success"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
};
export declare type TemplateConnectionFragment = {
    __typename?: "TemplateConnection";
} & {
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TemplatePayloadFragment = {
    __typename?: "TemplatePayload";
} & Pick<TemplatePayload, "lastSyncId" | "success"> & {
    template: {
        __typename?: "Template";
    } & Pick<Template, "id">;
};
export declare type UploadFileHeaderFragment = {
    __typename?: "UploadFileHeader";
} & Pick<UploadFileHeader, "key" | "value">;
export declare type UploadPayloadFragment = {
    __typename?: "UploadPayload";
} & Pick<UploadPayload, "lastSyncId" | "success"> & {
    uploadFile?: Maybe<{
        __typename?: "UploadFile";
    } & UploadFileFragment>;
};
export declare type UserAdminPayloadFragment = {
    __typename?: "UserAdminPayload";
} & Pick<UserAdminPayload, "success">;
export declare type UserConnectionFragment = {
    __typename?: "UserConnection";
} & {
    nodes: Array<{
        __typename?: "User";
    } & UserFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type UserPayloadFragment = {
    __typename?: "UserPayload";
} & Pick<UserPayload, "lastSyncId" | "success"> & {
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserSettingsFlagPayloadFragment = {
    __typename?: "UserSettingsFlagPayload";
} & Pick<UserSettingsFlagPayload, "flag" | "value" | "lastSyncId" | "success">;
export declare type UserSettingsFlagsResetPayloadFragment = {
    __typename?: "UserSettingsFlagsResetPayload";
} & Pick<UserSettingsFlagsResetPayload, "lastSyncId" | "success">;
export declare type UserSettingsPayloadFragment = {
    __typename?: "UserSettingsPayload";
} & Pick<UserSettingsPayload, "lastSyncId" | "success">;
export declare type UserSubscribeToNewsletterPayloadFragment = {
    __typename?: "UserSubscribeToNewsletterPayload";
} & Pick<UserSubscribeToNewsletterPayload, "success">;
export declare type ViewPreferencesPayloadFragment = {
    __typename?: "ViewPreferencesPayload";
} & Pick<ViewPreferencesPayload, "lastSyncId" | "success"> & {
    viewPreferences: {
        __typename?: "ViewPreferences";
    } & ViewPreferencesFragment;
};
export declare type WebhookConnectionFragment = {
    __typename?: "WebhookConnection";
} & {
    nodes: Array<{
        __typename?: "Webhook";
    } & WebhookFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WebhookPayloadFragment = {
    __typename?: "WebhookPayload";
} & Pick<WebhookPayload, "lastSyncId" | "success"> & {
    webhook: {
        __typename?: "Webhook";
    } & Pick<Webhook, "id">;
};
export declare type WorkflowStateConnectionFragment = {
    __typename?: "WorkflowStateConnection";
} & {
    nodes: Array<{
        __typename?: "WorkflowState";
    } & WorkflowStateFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WorkflowStatePayloadFragment = {
    __typename?: "WorkflowStatePayload";
} & Pick<WorkflowStatePayload, "lastSyncId" | "success"> & {
    workflowState: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type ApiKeysQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ApiKeysQuery = {
    __typename?: "Query";
} & {
    apiKeys: {
        __typename?: "ApiKeyConnection";
    } & ApiKeyConnectionFragment;
};
export declare type ApplicationWithAuthorizationQueryVariables = Exact<{
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]> | Scalars["String"];
}>;
export declare type ApplicationWithAuthorizationQuery = {
    __typename?: "Query";
} & {
    applicationWithAuthorization: {
        __typename?: "UserAuthorizedApplication";
    } & UserAuthorizedApplicationFragment;
};
export declare type ArchivedModelSyncQueryVariables = Exact<{
    identifier: Scalars["String"];
    modelClass: Scalars["String"];
}>;
export declare type ArchivedModelSyncQuery = {
    __typename?: "Query";
} & {
    archivedModelSync: {
        __typename?: "ArchiveResponse";
    } & ArchiveResponseFragment;
};
export declare type ArchivedModelsSyncQueryVariables = Exact<{
    before?: Maybe<Scalars["DateTime"]>;
    last?: Maybe<Scalars["Int"]>;
    modelClass: Scalars["String"];
    teamId: Scalars["String"];
    trashOption?: Maybe<TrashOptionType>;
}>;
export declare type ArchivedModelsSyncQuery = {
    __typename?: "Query";
} & {
    archivedModelsSync: {
        __typename?: "ArchiveResponse";
    } & ArchiveResponseFragment;
};
export declare type AttachmentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentQuery = {
    __typename?: "Query";
} & {
    attachment: {
        __typename?: "Attachment";
    } & AttachmentFragment;
};
export declare type AttachmentIssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentIssueQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type AttachmentIssue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type AttachmentIssue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_ChildrenQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type AttachmentIssue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_CommentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type AttachmentIssue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_HistoryQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type AttachmentIssue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_LabelsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type AttachmentIssue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_RelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_SubscribersQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type AttachmentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachments: {
        __typename?: "AttachmentConnection";
    } & AttachmentConnectionFragment;
};
export declare type AuthorizedApplicationsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AuthorizedApplicationsQuery = {
    __typename?: "Query";
} & {
    authorizedApplications: Array<{
        __typename?: "AuthorizedApplication";
    } & AuthorizedApplicationFragment>;
};
export declare type AvailableUsersQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AvailableUsersQuery = {
    __typename?: "Query";
} & {
    availableUsers: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type BillingDetailsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type BillingDetailsQuery = {
    __typename?: "Query";
} & {
    billingDetails: {
        __typename?: "BillingDetailsPayload";
    } & BillingDetailsPayloadFragment;
};
export declare type BillingDetails_PaymentMethodQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type BillingDetails_PaymentMethodQuery = {
    __typename?: "Query";
} & {
    billingDetails: {
        __typename?: "BillingDetailsPayload";
    } & {
        paymentMethod?: Maybe<{
            __typename?: "Card";
        } & CardFragment>;
    };
};
export declare type CollaborativeDocumentJoinQueryVariables = Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>;
export declare type CollaborativeDocumentJoinQuery = {
    __typename?: "Query";
} & {
    collaborativeDocumentJoin: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & CollaborationDocumentUpdatePayloadFragment;
};
export declare type CollaborativeDocumentJoin_StepsQueryVariables = Exact<{
    clientId: Scalars["String"];
    issueId: Scalars["String"];
    version: Scalars["Int"];
}>;
export declare type CollaborativeDocumentJoin_StepsQuery = {
    __typename?: "Query";
} & {
    collaborativeDocumentJoin: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & {
        steps?: Maybe<{
            __typename?: "StepsResponse";
        } & StepsResponseFragment>;
    };
};
export declare type CommentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CommentQuery = {
    __typename?: "Query";
} & {
    comment: {
        __typename?: "Comment";
    } & CommentFragment;
};
export declare type CommentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CommentsQuery = {
    __typename?: "Query";
} & {
    comments: {
        __typename?: "CommentConnection";
    } & CommentConnectionFragment;
};
export declare type CustomViewQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CustomViewQuery = {
    __typename?: "Query";
} & {
    customView: {
        __typename?: "CustomView";
    } & CustomViewFragment;
};
export declare type CustomViewsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CustomViewsQuery = {
    __typename?: "Query";
} & {
    customViews: {
        __typename?: "CustomViewConnection";
    } & CustomViewConnectionFragment;
};
export declare type CycleQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CycleQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & CycleFragment;
};
export declare type Cycle_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_IssuesQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Cycle_UncompletedIssuesUponCloseQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_UncompletedIssuesUponCloseQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        uncompletedIssuesUponClose: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type CyclesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CyclesQuery = {
    __typename?: "Query";
} & {
    cycles: {
        __typename?: "CycleConnection";
    } & CycleConnectionFragment;
};
export declare type EmojiQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type EmojiQuery = {
    __typename?: "Query";
} & {
    emoji: {
        __typename?: "Emoji";
    } & EmojiFragment;
};
export declare type EmojisQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type EmojisQuery = {
    __typename?: "Query";
} & {
    emojis: {
        __typename?: "EmojiConnection";
    } & EmojiConnectionFragment;
};
export declare type FavoriteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type FavoriteQuery = {
    __typename?: "Query";
} & {
    favorite: {
        __typename?: "Favorite";
    } & FavoriteFragment;
};
export declare type FavoritesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type FavoritesQuery = {
    __typename?: "Query";
} & {
    favorites: {
        __typename?: "FavoriteConnection";
    } & FavoriteConnectionFragment;
};
export declare type FigmaEmbedInfoQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfoQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & FigmaEmbedPayloadFragment;
};
export declare type FigmaEmbedInfo_FigmaEmbedQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfo_FigmaEmbedQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & {
        figmaEmbed?: Maybe<{
            __typename?: "FigmaEmbed";
        } & FigmaEmbedFragment>;
    };
};
export declare type IntegrationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationQuery = {
    __typename?: "Query";
} & {
    integration: {
        __typename?: "Integration";
    } & IntegrationFragment;
};
export declare type IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IntegrationsQuery = {
    __typename?: "Query";
} & {
    integrations: {
        __typename?: "IntegrationConnection";
    } & IntegrationConnectionFragment;
};
export declare type InviteInfoQueryVariables = Exact<{
    teamHash?: Maybe<Scalars["String"]>;
    userHash: Scalars["String"];
}>;
export declare type InviteInfoQuery = {
    __typename?: "Query";
} & {
    inviteInfo: {
        __typename?: "InvitePagePayload";
    } & InvitePagePayloadFragment;
};
export declare type InviteInfo_InviteDataQueryVariables = Exact<{
    teamHash?: Maybe<Scalars["String"]>;
    userHash: Scalars["String"];
}>;
export declare type InviteInfo_InviteDataQuery = {
    __typename?: "Query";
} & {
    inviteInfo: {
        __typename?: "InvitePagePayload";
    } & {
        inviteData?: Maybe<{
            __typename?: "InviteData";
        } & InviteDataFragment>;
    };
};
export declare type IssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type Issue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type Issue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_ChildrenQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Issue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_CommentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type Issue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_HistoryQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type Issue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_LabelsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Issue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_RelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_SubscribersQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type IssueImportFinishGithubOAuthQueryVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IssueImportFinishGithubOAuthQuery = {
    __typename?: "Query";
} & {
    issueImportFinishGithubOAuth: {
        __typename?: "OAuthTokenPayload";
    } & OAuthTokenPayloadFragment;
};
export declare type IssueLabelQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueLabelQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & IssueLabelFragment;
};
export declare type IssueLabel_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabel_IssuesQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type IssueLabelsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabelsQuery = {
    __typename?: "Query";
} & {
    issueLabels: {
        __typename?: "IssueLabelConnection";
    } & IssueLabelConnectionFragment;
};
export declare type IssuePriorityValuesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type IssuePriorityValuesQuery = {
    __typename?: "Query";
} & {
    issuePriorityValues: Array<{
        __typename?: "IssuePriorityValue";
    } & IssuePriorityValueFragment>;
};
export declare type IssueRelationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueRelationQuery = {
    __typename?: "Query";
} & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & IssueRelationFragment;
};
export declare type IssueRelationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueRelationsQuery = {
    __typename?: "Query";
} & {
    issueRelations: {
        __typename?: "IssueRelationConnection";
    } & IssueRelationConnectionFragment;
};
export declare type IssueSearchQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query: Scalars["String"];
}>;
export declare type IssueSearchQuery = {
    __typename?: "Query";
} & {
    issueSearch: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type IssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssuesQuery = {
    __typename?: "Query";
} & {
    issues: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type MilestoneQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type MilestoneQuery = {
    __typename?: "Query";
} & {
    milestone: {
        __typename?: "Milestone";
    } & MilestoneFragment;
};
export declare type Milestone_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Milestone_ProjectsQuery = {
    __typename?: "Query";
} & {
    milestone: {
        __typename?: "Milestone";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type MilestonesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type MilestonesQuery = {
    __typename?: "Query";
} & {
    milestones: {
        __typename?: "MilestoneConnection";
    } & MilestoneConnectionFragment;
};
export declare type NotificationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationQuery = {
    __typename?: "Query";
} & {
    notification: {
        __typename?: "Notification";
    } & NotificationFragment;
};
export declare type NotificationSubscriptionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationSubscriptionQuery = {
    __typename?: "Query";
} & {
    notificationSubscription: {
        __typename?: "NotificationSubscription";
    } & NotificationSubscriptionFragment;
};
export declare type NotificationSubscriptionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationSubscriptionsQuery = {
    __typename?: "Query";
} & {
    notificationSubscriptions: {
        __typename?: "NotificationSubscriptionConnection";
    } & NotificationSubscriptionConnectionFragment;
};
export declare type NotificationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationsQuery = {
    __typename?: "Query";
} & {
    notifications: {
        __typename?: "NotificationConnection";
    } & NotificationConnectionFragment;
};
export declare type OrganizationQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & OrganizationFragment;
};
export declare type Organization_IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_IntegrationsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        integrations: {
            __typename?: "IntegrationConnection";
        } & IntegrationConnectionFragment;
    };
};
export declare type Organization_MilestonesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_MilestonesQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        milestones: {
            __typename?: "MilestoneConnection";
        } & MilestoneConnectionFragment;
    };
};
export declare type Organization_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_TeamsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type Organization_UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_UsersQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        users: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type OrganizationExistsQueryVariables = Exact<{
    urlKey: Scalars["String"];
}>;
export declare type OrganizationExistsQuery = {
    __typename?: "Query";
} & {
    organizationExists: {
        __typename?: "OrganizationExistsPayload";
    } & OrganizationExistsPayloadFragment;
};
export declare type OrganizationInviteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteQuery = {
    __typename?: "Query";
} & {
    organizationInvite: {
        __typename?: "IssueLabel";
    } & IssueLabelFragment;
};
export declare type OrganizationInvite_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type OrganizationInvite_IssuesQuery = {
    __typename?: "Query";
} & {
    organizationInvite: {
        __typename?: "IssueLabel";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type OrganizationInvitesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type OrganizationInvitesQuery = {
    __typename?: "Query";
} & {
    organizationInvites: {
        __typename?: "OrganizationInviteConnection";
    } & OrganizationInviteConnectionFragment;
};
export declare type ProjectQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & ProjectFragment;
};
export declare type Project_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_IssuesQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Project_LinksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_LinksQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        links: {
            __typename?: "ProjectLinkConnection";
        } & ProjectLinkConnectionFragment;
    };
};
export declare type Project_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_MembersQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Project_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_TeamsQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type ProjectLinkQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectLinkQuery = {
    __typename?: "Query";
} & {
    projectLink: {
        __typename?: "ProjectLink";
    } & ProjectLinkFragment;
};
export declare type ProjectLinksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectLinksQuery = {
    __typename?: "Query";
} & {
    projectLinks: {
        __typename?: "ProjectLinkConnection";
    } & ProjectLinkConnectionFragment;
};
export declare type ProjectsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectsQuery = {
    __typename?: "Query";
} & {
    projects: {
        __typename?: "ProjectConnection";
    } & ProjectConnectionFragment;
};
export declare type PushSubscriptionTestQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type PushSubscriptionTestQuery = {
    __typename?: "Query";
} & {
    pushSubscriptionTest: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type ReactionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ReactionQuery = {
    __typename?: "Query";
} & {
    reaction: {
        __typename?: "Reaction";
    } & ReactionFragment;
};
export declare type ReactionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ReactionsQuery = {
    __typename?: "Query";
} & {
    reactions: {
        __typename?: "ReactionConnection";
    } & ReactionConnectionFragment;
};
export declare type SsoUrlFromEmailQueryVariables = Exact<{
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
}>;
export declare type SsoUrlFromEmailQuery = {
    __typename?: "Query";
} & {
    ssoUrlFromEmail: {
        __typename?: "SsoUrlFromEmailResponse";
    } & SsoUrlFromEmailResponseFragment;
};
export declare type SubscriptionQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type SubscriptionQuery = {
    __typename?: "Query";
} & {
    subscription?: Maybe<{
        __typename?: "Subscription";
    } & SubscriptionFragment>;
};
export declare type SyncBootstrapQueryVariables = Exact<{
    databaseVersion?: Maybe<Scalars["Int"]>;
    sinceSyncId?: Maybe<Scalars["Int"]>;
    syncGroups?: Maybe<Array<Scalars["String"]> | Scalars["String"]>;
}>;
export declare type SyncBootstrapQuery = {
    __typename?: "Query";
} & {
    syncBootstrap: {
        __typename?: "SyncResponse";
    } & SyncResponseFragment;
};
export declare type TeamQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & TeamFragment;
};
export declare type Team_CyclesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_CyclesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        cycles: {
            __typename?: "CycleConnection";
        } & CycleConnectionFragment;
    };
};
export declare type Team_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_IssuesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Team_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_LabelsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Team_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembersQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Team_MembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembershipsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        memberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Team_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_ProjectsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type Team_StatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_StatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        states: {
            __typename?: "WorkflowStateConnection";
        } & WorkflowStateConnectionFragment;
    };
};
export declare type Team_TemplatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_TemplatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        templates: {
            __typename?: "TemplateConnection";
        } & TemplateConnectionFragment;
    };
};
export declare type Team_WebhooksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_WebhooksQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        webhooks: {
            __typename?: "WebhookConnection";
        } & WebhookConnectionFragment;
    };
};
export declare type TeamMembershipQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamMembershipQuery = {
    __typename?: "Query";
} & {
    teamMembership: {
        __typename?: "TeamMembership";
    } & TeamMembershipFragment;
};
export declare type TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    teamMemberships: {
        __typename?: "TeamMembershipConnection";
    } & TeamMembershipConnectionFragment;
};
export declare type TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamsQuery = {
    __typename?: "Query";
} & {
    teams: {
        __typename?: "TeamConnection";
    } & TeamConnectionFragment;
};
export declare type TemplateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TemplateQuery = {
    __typename?: "Query";
} & {
    template: {
        __typename?: "Template";
    } & TemplateFragment;
};
export declare type TemplatesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type TemplatesQuery = {
    __typename?: "Query";
} & {
    templates: Array<{
        __typename?: "Template";
    } & TemplateFragment>;
};
export declare type UserQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & UserFragment;
};
export declare type User_AssignedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_CreatedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_TeamMembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type User_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type UserSettingsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSettingsQuery = {
    __typename?: "Query";
} & {
    userSettings: {
        __typename?: "UserSettings";
    } & UserSettingsFragment;
};
export declare type UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type UsersQuery = {
    __typename?: "Query";
} & {
    users: {
        __typename?: "UserConnection";
    } & UserConnectionFragment;
};
export declare type ViewerQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type ViewerQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & UserFragment;
};
export declare type Viewer_AssignedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_CreatedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Viewer_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type WebhookQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WebhookQuery = {
    __typename?: "Query";
} & {
    webhook: {
        __typename?: "Webhook";
    } & WebhookFragment;
};
export declare type WebhooksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WebhooksQuery = {
    __typename?: "Query";
} & {
    webhooks: {
        __typename?: "WebhookConnection";
    } & WebhookConnectionFragment;
};
export declare type WorkflowStateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WorkflowStateQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & WorkflowStateFragment;
};
export declare type WorkflowState_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowState_IssuesQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type WorkflowStatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowStatesQuery = {
    __typename?: "Query";
} & {
    workflowStates: {
        __typename?: "WorkflowStateConnection";
    } & WorkflowStateConnectionFragment;
};
export declare type ApiKeyCreateMutationVariables = Exact<{
    input: ApiKeyCreateInput;
}>;
export declare type ApiKeyCreateMutation = {
    __typename?: "Mutation";
} & {
    apiKeyCreate: {
        __typename?: "ApiKeyPayload";
    } & ApiKeyPayloadFragment;
};
export declare type ApiKeyDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ApiKeyDeleteMutation = {
    __typename?: "Mutation";
} & {
    apiKeyDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type AttachmentArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentArchiveMutation = {
    __typename?: "Mutation";
} & {
    attachmentArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type AttachmentCreateMutationVariables = Exact<{
    input: AttachmentCreateInput;
}>;
export declare type AttachmentCreateMutation = {
    __typename?: "Mutation";
} & {
    attachmentCreate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: AttachmentUpdateInput;
}>;
export declare type AttachmentUpdateMutation = {
    __typename?: "Mutation";
} & {
    attachmentUpdate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type BillingEmailUpdateMutationVariables = Exact<{
    input: BillingEmailUpdateInput;
}>;
export declare type BillingEmailUpdateMutation = {
    __typename?: "Mutation";
} & {
    billingEmailUpdate: {
        __typename?: "BillingEmailPayload";
    } & BillingEmailPayloadFragment;
};
export declare type CollaborativeDocumentUpdateMutationVariables = Exact<{
    input: CollaborationDocumentUpdateInput;
}>;
export declare type CollaborativeDocumentUpdateMutation = {
    __typename?: "Mutation";
} & {
    collaborativeDocumentUpdate: {
        __typename?: "CollaborationDocumentUpdatePayload";
    } & CollaborationDocumentUpdatePayloadFragment;
};
export declare type CommentCreateMutationVariables = Exact<{
    input: CommentCreateInput;
}>;
export declare type CommentCreateMutation = {
    __typename?: "Mutation";
} & {
    commentCreate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type CommentDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CommentDeleteMutation = {
    __typename?: "Mutation";
} & {
    commentDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CommentUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CommentUpdateInput;
}>;
export declare type CommentUpdateMutation = {
    __typename?: "Mutation";
} & {
    commentUpdate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type ContactCreateMutationVariables = Exact<{
    input: ContactCreateInput;
}>;
export declare type ContactCreateMutation = {
    __typename?: "Mutation";
} & {
    contactCreate: {
        __typename?: "ContactPayload";
    } & ContactPayloadFragment;
};
export declare type CreateCsvExportReportMutationVariables = Exact<{
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]> | Scalars["String"]>;
}>;
export declare type CreateCsvExportReportMutation = {
    __typename?: "Mutation";
} & {
    createCsvExportReport: {
        __typename?: "CreateCsvExportReportPayload";
    } & CreateCsvExportReportPayloadFragment;
};
export declare type CreateOrganizationFromOnboardingMutationVariables = Exact<{
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
}>;
export declare type CreateOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    createOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type CustomViewCreateMutationVariables = Exact<{
    input: CustomViewCreateInput;
}>;
export declare type CustomViewCreateMutation = {
    __typename?: "Mutation";
} & {
    customViewCreate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type CustomViewDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CustomViewDeleteMutation = {
    __typename?: "Mutation";
} & {
    customViewDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CustomViewUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CustomViewUpdateInput;
}>;
export declare type CustomViewUpdateMutation = {
    __typename?: "Mutation";
} & {
    customViewUpdate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type CycleArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CycleArchiveMutation = {
    __typename?: "Mutation";
} & {
    cycleArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type CycleCreateMutationVariables = Exact<{
    input: CycleCreateInput;
}>;
export declare type CycleCreateMutation = {
    __typename?: "Mutation";
} & {
    cycleCreate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type CycleUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: CycleUpdateInput;
}>;
export declare type CycleUpdateMutation = {
    __typename?: "Mutation";
} & {
    cycleUpdate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type DebugCreateSamlOrgMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DebugCreateSamlOrgMutation = {
    __typename?: "Mutation";
} & {
    debugCreateSAMLOrg: {
        __typename?: "DebugPayload";
    } & DebugPayloadFragment;
};
export declare type DebugFailWithInternalErrorMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DebugFailWithInternalErrorMutation = {
    __typename?: "Mutation";
} & {
    debugFailWithInternalError: {
        __typename?: "DebugPayload";
    } & DebugPayloadFragment;
};
export declare type DebugFailWithWarningMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DebugFailWithWarningMutation = {
    __typename?: "Mutation";
} & {
    debugFailWithWarning: {
        __typename?: "DebugPayload";
    } & DebugPayloadFragment;
};
export declare type EmailTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type EmailTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    emailTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type EmailUnsubscribeMutationVariables = Exact<{
    input: EmailUnsubscribeInput;
}>;
export declare type EmailUnsubscribeMutation = {
    __typename?: "Mutation";
} & {
    emailUnsubscribe: {
        __typename?: "EmailUnsubscribePayload";
    } & EmailUnsubscribePayloadFragment;
};
export declare type EmailUserAccountAuthChallengeMutationVariables = Exact<{
    input: EmailUserAccountAuthChallengeInput;
}>;
export declare type EmailUserAccountAuthChallengeMutation = {
    __typename?: "Mutation";
} & {
    emailUserAccountAuthChallenge: {
        __typename?: "EmailUserAccountAuthChallengeResponse";
    } & EmailUserAccountAuthChallengeResponseFragment;
};
export declare type EmojiCreateMutationVariables = Exact<{
    input: EmojiCreateInput;
}>;
export declare type EmojiCreateMutation = {
    __typename?: "Mutation";
} & {
    emojiCreate: {
        __typename?: "EmojiPayload";
    } & EmojiPayloadFragment;
};
export declare type EmojiDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type EmojiDeleteMutation = {
    __typename?: "Mutation";
} & {
    emojiDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type EventCreateMutationVariables = Exact<{
    input: EventCreateInput;
}>;
export declare type EventCreateMutation = {
    __typename?: "Mutation";
} & {
    eventCreate: {
        __typename?: "EventPayload";
    } & EventPayloadFragment;
};
export declare type FavoriteCreateMutationVariables = Exact<{
    input: FavoriteCreateInput;
}>;
export declare type FavoriteCreateMutation = {
    __typename?: "Mutation";
} & {
    favoriteCreate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type FavoriteDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type FavoriteDeleteMutation = {
    __typename?: "Mutation";
} & {
    favoriteDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type FavoriteUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: FavoriteUpdateInput;
}>;
export declare type FavoriteUpdateMutation = {
    __typename?: "Mutation";
} & {
    favoriteUpdate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type FeedbackCreateMutationVariables = Exact<{
    input: FeedbackCreateInput;
}>;
export declare type FeedbackCreateMutation = {
    __typename?: "Mutation";
} & {
    feedbackCreate: {
        __typename?: "FeedbackPayload";
    } & FeedbackPayloadFragment;
};
export declare type FileUploadMutationVariables = Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
}>;
export declare type FileUploadMutation = {
    __typename?: "Mutation";
} & {
    fileUpload: {
        __typename?: "UploadPayload";
    } & UploadPayloadFragment;
};
export declare type GoogleUserAccountAuthMutationVariables = Exact<{
    input: GoogleUserAccountAuthInput;
}>;
export declare type GoogleUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    googleUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type ImageUploadFromUrlMutationVariables = Exact<{
    url: Scalars["String"];
}>;
export declare type ImageUploadFromUrlMutation = {
    __typename?: "Mutation";
} & {
    imageUploadFromUrl: {
        __typename?: "ImageUploadFromUrlPayload";
    } & ImageUploadFromUrlPayloadFragment;
};
export declare type IntegrationDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationDeleteMutation = {
    __typename?: "Mutation";
} & {
    integrationDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IntegrationFigmaMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationFigmaMutation = {
    __typename?: "Mutation";
} & {
    integrationFigma: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGithubConnectMutationVariables = Exact<{
    installationId: Scalars["String"];
}>;
export declare type IntegrationGithubConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGithubConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGitlabConnectMutationVariables = Exact<{
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
}>;
export declare type IntegrationGitlabConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGitlabConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGoogleSheetsMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IntegrationGoogleSheetsMutation = {
    __typename?: "Mutation";
} & {
    integrationGoogleSheets: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationResourceArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationResourceArchiveMutation = {
    __typename?: "Mutation";
} & {
    integrationResourceArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IntegrationSentryConnectMutationVariables = Exact<{
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
}>;
export declare type IntegrationSentryConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationSentryConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IntegrationSlackMutation = {
    __typename?: "Mutation";
} & {
    integrationSlack: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackImportEmojisMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackImportEmojisMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackImportEmojis: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPersonalMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackPersonalMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPersonal: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPostMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IntegrationSlackPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackProjectPostMutationVariables = Exact<{
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackProjectPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackProjectPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationZendeskMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
}>;
export declare type IntegrationZendeskMutation = {
    __typename?: "Mutation";
} & {
    integrationZendesk: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IssueArchiveMutationVariables = Exact<{
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IssueArchiveMutation = {
    __typename?: "Mutation";
} & {
    issueArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueCreateMutationVariables = Exact<{
    input: IssueCreateInput;
}>;
export declare type IssueCreateMutation = {
    __typename?: "Mutation";
} & {
    issueCreate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type IssueImportCreateAsanaMutationVariables = Exact<{
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateAsanaMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateAsana: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateClubhouseMutationVariables = Exact<{
    clubhouseTeamName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateClubhouseMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateClubhouse: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateGithubMutationVariables = Exact<{
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateGithubMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateGithub: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateJiraMutationVariables = Exact<{
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    teamId: Scalars["String"];
}>;
export declare type IssueImportCreateJiraMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateJira: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportDeleteMutationVariables = Exact<{
    issueImportId: Scalars["String"];
}>;
export declare type IssueImportDeleteMutation = {
    __typename?: "Mutation";
} & {
    issueImportDelete: {
        __typename?: "IssueImportDeletePayload";
    } & IssueImportDeletePayloadFragment;
};
export declare type IssueLabelArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueLabelArchiveMutation = {
    __typename?: "Mutation";
} & {
    issueLabelArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueLabelCreateMutationVariables = Exact<{
    input: IssueLabelCreateInput;
}>;
export declare type IssueLabelCreateMutation = {
    __typename?: "Mutation";
} & {
    issueLabelCreate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type IssueLabelUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
}>;
export declare type IssueLabelUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueLabelUpdate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type IssueRelationCreateMutationVariables = Exact<{
    input: IssueRelationCreateInput;
}>;
export declare type IssueRelationCreateMutation = {
    __typename?: "Mutation";
} & {
    issueRelationCreate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type IssueRelationDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueRelationDeleteMutation = {
    __typename?: "Mutation";
} & {
    issueRelationDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueRelationUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
}>;
export declare type IssueRelationUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueRelationUpdate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type IssueUnarchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueUnarchiveMutation = {
    __typename?: "Mutation";
} & {
    issueUnarchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type IssueUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueUpdateInput;
}>;
export declare type IssueUpdateMutation = {
    __typename?: "Mutation";
} & {
    issueUpdate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type JoinOrganizationFromOnboardingMutationVariables = Exact<{
    input: JoinOrganizationInput;
}>;
export declare type JoinOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    joinOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type LeaveOrganizationMutationVariables = Exact<{
    organizationId: Scalars["String"];
}>;
export declare type LeaveOrganizationMutation = {
    __typename?: "Mutation";
} & {
    leaveOrganization: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type MilestoneCreateMutationVariables = Exact<{
    input: MilestoneCreateInput;
}>;
export declare type MilestoneCreateMutation = {
    __typename?: "Mutation";
} & {
    milestoneCreate: {
        __typename?: "MilestonePayload";
    } & MilestonePayloadFragment;
};
export declare type MilestoneDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type MilestoneDeleteMutation = {
    __typename?: "Mutation";
} & {
    milestoneDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type MilestoneUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: MilestoneUpdateInput;
}>;
export declare type MilestoneUpdateMutation = {
    __typename?: "Mutation";
} & {
    milestoneUpdate: {
        __typename?: "MilestonePayload";
    } & MilestonePayloadFragment;
};
export declare type NotificationArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationArchiveMutation = {
    __typename?: "Mutation";
} & {
    notificationArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationCreateMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>;
export declare type NotificationCreateMutation = {
    __typename?: "Mutation";
} & {
    notificationCreate: {
        __typename?: "NotificationPayload";
    } & NotificationPayloadFragment;
};
export declare type NotificationDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationDeleteMutation = {
    __typename?: "Mutation";
} & {
    notificationDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationSubscriptionCreateMutationVariables = Exact<{
    input: NotificationSubscriptionCreateInput;
}>;
export declare type NotificationSubscriptionCreateMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionCreate: {
        __typename?: "NotificationSubscriptionPayload";
    } & NotificationSubscriptionPayloadFragment;
};
export declare type NotificationSubscriptionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationSubscriptionDeleteMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationUnarchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationUnarchiveMutation = {
    __typename?: "Mutation";
} & {
    notificationUnarchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type NotificationUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>;
export declare type NotificationUpdateMutation = {
    __typename?: "Mutation";
} & {
    notificationUpdate: {
        __typename?: "NotificationPayload";
    } & NotificationPayloadFragment;
};
export declare type OauthClientArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OauthClientArchiveMutation = {
    __typename?: "Mutation";
} & {
    oauthClientArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OauthClientCreateMutationVariables = Exact<{
    input: OauthClientCreateInput;
}>;
export declare type OauthClientCreateMutation = {
    __typename?: "Mutation";
} & {
    oauthClientCreate: {
        __typename?: "OauthClientPayload";
    } & OauthClientPayloadFragment;
};
export declare type OauthClientRotateSecretMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OauthClientRotateSecretMutation = {
    __typename?: "Mutation";
} & {
    oauthClientRotateSecret: {
        __typename?: "RotateSecretPayload";
    } & RotateSecretPayloadFragment;
};
export declare type OauthClientUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: OauthClientUpdateInput;
}>;
export declare type OauthClientUpdateMutation = {
    __typename?: "Mutation";
} & {
    oauthClientUpdate: {
        __typename?: "OauthClientPayload";
    } & OauthClientPayloadFragment;
};
export declare type OauthTokenRevokeMutationVariables = Exact<{
    appId: Scalars["String"];
    scope: Array<Scalars["String"]> | Scalars["String"];
}>;
export declare type OauthTokenRevokeMutation = {
    __typename?: "Mutation";
} & {
    oauthTokenRevoke: {
        __typename?: "OauthTokenRevokePayload";
    } & OauthTokenRevokePayloadFragment;
};
export declare type OrganizationDeleteMutationVariables = Exact<{
    input: DeleteOrganizationInput;
}>;
export declare type OrganizationDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationDelete: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type OrganizationDeleteChallengeMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationDeleteChallengeMutation = {
    __typename?: "Mutation";
} & {
    organizationDeleteChallenge: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type OrganizationDomainCreateMutationVariables = Exact<{
    input: OrganizationDomainCreateInput;
}>;
export declare type OrganizationDomainCreateMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainCreate: {
        __typename?: "OrganizationDomainPayload";
    } & OrganizationDomainPayloadFragment;
};
export declare type OrganizationDomainDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationDomainDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OrganizationDomainVerifyMutationVariables = Exact<{
    input: OrganizationDomainVerificationInput;
}>;
export declare type OrganizationDomainVerifyMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainVerify: {
        __typename?: "OrganizationDomainPayload";
    } & OrganizationDomainPayloadFragment;
};
export declare type OrganizationInviteCreateMutationVariables = Exact<{
    input: OrganizationInviteCreateInput;
}>;
export declare type OrganizationInviteCreateMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteCreate: {
        __typename?: "OrganizationInvitePayload";
    } & OrganizationInvitePayloadFragment;
};
export declare type OrganizationInviteDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteDeleteMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type OrganizationUpdateMutationVariables = Exact<{
    input: UpdateOrganizationInput;
}>;
export declare type OrganizationUpdateMutation = {
    __typename?: "Mutation";
} & {
    organizationUpdate: {
        __typename?: "OrganizationPayload";
    } & OrganizationPayloadFragment;
};
export declare type ProjectArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectArchiveMutation = {
    __typename?: "Mutation";
} & {
    projectArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ProjectCreateMutationVariables = Exact<{
    input: ProjectCreateInput;
}>;
export declare type ProjectCreateMutation = {
    __typename?: "Mutation";
} & {
    projectCreate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type ProjectLinkCreateMutationVariables = Exact<{
    input: ProjectLinkCreateInput;
}>;
export declare type ProjectLinkCreateMutation = {
    __typename?: "Mutation";
} & {
    projectLinkCreate: {
        __typename?: "ProjectLinkPayload";
    } & ProjectLinkPayloadFragment;
};
export declare type ProjectLinkDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectLinkDeleteMutation = {
    __typename?: "Mutation";
} & {
    projectLinkDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ProjectUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectUpdateInput;
}>;
export declare type ProjectUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectUpdate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type PushSubscriptionCreateMutationVariables = Exact<{
    input: PushSubscriptionCreateInput;
}>;
export declare type PushSubscriptionCreateMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionCreate: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type PushSubscriptionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type PushSubscriptionDeleteMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionDelete: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type ReactionCreateMutationVariables = Exact<{
    input: ReactionCreateInput;
}>;
export declare type ReactionCreateMutation = {
    __typename?: "Mutation";
} & {
    reactionCreate: {
        __typename?: "ReactionPayload";
    } & ReactionPayloadFragment;
};
export declare type ReactionDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ReactionDeleteMutation = {
    __typename?: "Mutation";
} & {
    reactionDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type RefreshGoogleSheetsDataMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type RefreshGoogleSheetsDataMutation = {
    __typename?: "Mutation";
} & {
    refreshGoogleSheetsData: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type ResentOrganizationInviteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ResentOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    resentOrganizationInvite: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type SamlTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type SamlTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    samlTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type SubscriptionArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type SubscriptionArchiveMutation = {
    __typename?: "Mutation";
} & {
    subscriptionArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type SubscriptionSessionCreateMutationVariables = Exact<{
    plan: Scalars["String"];
}>;
export declare type SubscriptionSessionCreateMutation = {
    __typename?: "Mutation";
} & {
    subscriptionSessionCreate: {
        __typename?: "SubscriptionSessionPayload";
    } & SubscriptionSessionPayloadFragment;
};
export declare type SubscriptionUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: SubscriptionUpdateInput;
}>;
export declare type SubscriptionUpdateMutation = {
    __typename?: "Mutation";
} & {
    subscriptionUpdate: {
        __typename?: "SubscriptionPayload";
    } & SubscriptionPayloadFragment;
};
export declare type SubscriptionUpdateSessionCreateMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type SubscriptionUpdateSessionCreateMutation = {
    __typename?: "Mutation";
} & {
    subscriptionUpdateSessionCreate: {
        __typename?: "SubscriptionSessionPayload";
    } & SubscriptionSessionPayloadFragment;
};
export declare type SubscriptionUpgradeMutationVariables = Exact<{
    id: Scalars["String"];
    type: Scalars["String"];
}>;
export declare type SubscriptionUpgradeMutation = {
    __typename?: "Mutation";
} & {
    subscriptionUpgrade: {
        __typename?: "SubscriptionPayload";
    } & SubscriptionPayloadFragment;
};
export declare type TeamArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamArchiveMutation = {
    __typename?: "Mutation";
} & {
    teamArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamCreateMutationVariables = Exact<{
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
}>;
export declare type TeamCreateMutation = {
    __typename?: "Mutation";
} & {
    teamCreate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type TeamDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamDeleteMutation = {
    __typename?: "Mutation";
} & {
    teamDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamMembershipCreateMutationVariables = Exact<{
    input: TeamMembershipCreateInput;
}>;
export declare type TeamMembershipCreateMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipCreate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type TeamMembershipDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamMembershipDeleteMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TeamMembershipUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
}>;
export declare type TeamMembershipUpdateMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipUpdate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type TeamUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamUpdateInput;
}>;
export declare type TeamUpdateMutation = {
    __typename?: "Mutation";
} & {
    teamUpdate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type TemplateCreateMutationVariables = Exact<{
    input: TemplateCreateInput;
}>;
export declare type TemplateCreateMutation = {
    __typename?: "Mutation";
} & {
    templateCreate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type TemplateDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TemplateDeleteMutation = {
    __typename?: "Mutation";
} & {
    templateDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type TemplateUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TemplateUpdateInput;
}>;
export declare type TemplateUpdateMutation = {
    __typename?: "Mutation";
} & {
    templateUpdate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type UserDemoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserDemoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userDemoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserFlagUpdateMutationVariables = Exact<{
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
}>;
export declare type UserFlagUpdateMutation = {
    __typename?: "Mutation";
} & {
    userFlagUpdate: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserPromoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserPromoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userPromoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserSettingsFlagIncrementMutationVariables = Exact<{
    flag: Scalars["String"];
}>;
export declare type UserSettingsFlagIncrementMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagIncrement: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserSettingsFlagsResetMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSettingsFlagsResetMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagsReset: {
        __typename?: "UserSettingsFlagsResetPayload";
    } & UserSettingsFlagsResetPayloadFragment;
};
export declare type UserSettingsUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
}>;
export declare type UserSettingsUpdateMutation = {
    __typename?: "Mutation";
} & {
    userSettingsUpdate: {
        __typename?: "UserSettingsPayload";
    } & UserSettingsPayloadFragment;
};
export declare type UserSubscribeToNewsletterMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSubscribeToNewsletterMutation = {
    __typename?: "Mutation";
} & {
    userSubscribeToNewsletter: {
        __typename?: "UserSubscribeToNewsletterPayload";
    } & UserSubscribeToNewsletterPayloadFragment;
};
export declare type UserSuspendMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserSuspendMutation = {
    __typename?: "Mutation";
} & {
    userSuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserUnsuspendMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserUnsuspendMutation = {
    __typename?: "Mutation";
} & {
    userUnsuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: UpdateUserInput;
}>;
export declare type UserUpdateMutation = {
    __typename?: "Mutation";
} & {
    userUpdate: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type ViewPreferencesCreateMutationVariables = Exact<{
    input: ViewPreferencesCreateInput;
}>;
export declare type ViewPreferencesCreateMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesCreate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type ViewPreferencesDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ViewPreferencesDeleteMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type ViewPreferencesUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
}>;
export declare type ViewPreferencesUpdateMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesUpdate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type WebhookCreateMutationVariables = Exact<{
    input: WebhookCreateInput;
}>;
export declare type WebhookCreateMutation = {
    __typename?: "Mutation";
} & {
    webhookCreate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type WebhookDeleteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WebhookDeleteMutation = {
    __typename?: "Mutation";
} & {
    webhookDelete: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type WebhookUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: WebhookUpdateInput;
}>;
export declare type WebhookUpdateMutation = {
    __typename?: "Mutation";
} & {
    webhookUpdate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type WorkflowStateArchiveMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WorkflowStateArchiveMutation = {
    __typename?: "Mutation";
} & {
    workflowStateArchive: {
        __typename?: "ArchivePayload";
    } & ArchivePayloadFragment;
};
export declare type WorkflowStateCreateMutationVariables = Exact<{
    input: WorkflowStateCreateInput;
}>;
export declare type WorkflowStateCreateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateCreate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare type WorkflowStateUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
}>;
export declare type WorkflowStateUpdateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateUpdate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare const FileUploadFragmentDoc: DocumentNode<FileUploadFragment, unknown>;
export declare const TemplateFragmentDoc: DocumentNode<TemplateFragment, unknown>;
export declare const UserFragmentDoc: DocumentNode<UserFragment, unknown>;
export declare const UserAccountFragmentDoc: DocumentNode<UserAccountFragment, unknown>;
export declare const DocumentStepFragmentDoc: DocumentNode<DocumentStepFragment, unknown>;
export declare const SyncResponseFragmentDoc: DocumentNode<SyncResponseFragment, unknown>;
export declare const ArchiveResponseFragmentDoc: DocumentNode<ArchiveResponseFragment, unknown>;
export declare const GithubRepoFragmentDoc: DocumentNode<GithubRepoFragment, unknown>;
export declare const GithubOrgFragmentDoc: DocumentNode<GithubOrgFragment, unknown>;
export declare const OAuthTokenPayloadFragmentDoc: DocumentNode<OAuthTokenPayloadFragment, unknown>;
export declare const AuthorizedApplicationFragmentDoc: DocumentNode<AuthorizedApplicationFragment, unknown>;
export declare const UserAuthorizedApplicationFragmentDoc: DocumentNode<UserAuthorizedApplicationFragment, unknown>;
export declare const ApplicationFragmentDoc: DocumentNode<ApplicationFragment, unknown>;
export declare const GoogleSheetsSettingsFragmentDoc: DocumentNode<GoogleSheetsSettingsFragment, unknown>;
export declare const SentrySettingsFragmentDoc: DocumentNode<SentrySettingsFragment, unknown>;
export declare const SlackPostSettingsFragmentDoc: DocumentNode<SlackPostSettingsFragment, unknown>;
export declare const ZendeskSettingsFragmentDoc: DocumentNode<ZendeskSettingsFragment, unknown>;
export declare const IntegrationSettingsFragmentDoc: DocumentNode<IntegrationSettingsFragment, unknown>;
export declare const SamlConfigurationFragmentDoc: DocumentNode<SamlConfigurationFragment, unknown>;
export declare const UserSettingsFragmentDoc: DocumentNode<UserSettingsFragment, unknown>;
export declare const SubscriptionFragmentDoc: DocumentNode<SubscriptionFragment, unknown>;
export declare const ApiKeyFragmentDoc: DocumentNode<ApiKeyFragment, unknown>;
export declare const PageInfoFragmentDoc: DocumentNode<PageInfoFragment, unknown>;
export declare const ApiKeyConnectionFragmentDoc: DocumentNode<ApiKeyConnectionFragment, unknown>;
export declare const ApiKeyPayloadFragmentDoc: DocumentNode<ApiKeyPayloadFragment, unknown>;
export declare const ArchivePayloadFragmentDoc: DocumentNode<ArchivePayloadFragment, unknown>;
export declare const AttachmentFragmentDoc: DocumentNode<AttachmentFragment, unknown>;
export declare const AttachmentConnectionFragmentDoc: DocumentNode<AttachmentConnectionFragment, unknown>;
export declare const AttachmentPayloadFragmentDoc: DocumentNode<AttachmentPayloadFragment, unknown>;
export declare const OrganizationFragmentDoc: DocumentNode<OrganizationFragment, unknown>;
export declare const AuthResolverResponseFragmentDoc: DocumentNode<AuthResolverResponseFragment, unknown>;
export declare const InvoiceFragmentDoc: DocumentNode<InvoiceFragment, unknown>;
export declare const CardFragmentDoc: DocumentNode<CardFragment, unknown>;
export declare const BillingDetailsPayloadFragmentDoc: DocumentNode<BillingDetailsPayloadFragment, unknown>;
export declare const BillingEmailPayloadFragmentDoc: DocumentNode<BillingEmailPayloadFragment, unknown>;
export declare const StepsResponseFragmentDoc: DocumentNode<StepsResponseFragment, unknown>;
export declare const CollaborationDocumentUpdatePayloadFragmentDoc: DocumentNode<CollaborationDocumentUpdatePayloadFragment, unknown>;
export declare const CommentFragmentDoc: DocumentNode<CommentFragment, unknown>;
export declare const CommentConnectionFragmentDoc: DocumentNode<CommentConnectionFragment, unknown>;
export declare const CommentPayloadFragmentDoc: DocumentNode<CommentPayloadFragment, unknown>;
export declare const ContactPayloadFragmentDoc: DocumentNode<ContactPayloadFragment, unknown>;
export declare const CreateCsvExportReportPayloadFragmentDoc: DocumentNode<CreateCsvExportReportPayloadFragment, unknown>;
export declare const CreateOrJoinOrganizationResponseFragmentDoc: DocumentNode<CreateOrJoinOrganizationResponseFragment, unknown>;
export declare const CustomViewFragmentDoc: DocumentNode<CustomViewFragment, unknown>;
export declare const CustomViewConnectionFragmentDoc: DocumentNode<CustomViewConnectionFragment, unknown>;
export declare const CustomViewPayloadFragmentDoc: DocumentNode<CustomViewPayloadFragment, unknown>;
export declare const CycleFragmentDoc: DocumentNode<CycleFragment, unknown>;
export declare const CycleConnectionFragmentDoc: DocumentNode<CycleConnectionFragment, unknown>;
export declare const CyclePayloadFragmentDoc: DocumentNode<CyclePayloadFragment, unknown>;
export declare const DebugPayloadFragmentDoc: DocumentNode<DebugPayloadFragment, unknown>;
export declare const EmailUnsubscribePayloadFragmentDoc: DocumentNode<EmailUnsubscribePayloadFragment, unknown>;
export declare const EmailUserAccountAuthChallengeResponseFragmentDoc: DocumentNode<EmailUserAccountAuthChallengeResponseFragment, unknown>;
export declare const EmojiFragmentDoc: DocumentNode<EmojiFragment, unknown>;
export declare const EmojiConnectionFragmentDoc: DocumentNode<EmojiConnectionFragment, unknown>;
export declare const EmojiPayloadFragmentDoc: DocumentNode<EmojiPayloadFragment, unknown>;
export declare const EventPayloadFragmentDoc: DocumentNode<EventPayloadFragment, unknown>;
export declare const FavoriteFragmentDoc: DocumentNode<FavoriteFragment, unknown>;
export declare const FavoriteConnectionFragmentDoc: DocumentNode<FavoriteConnectionFragment, unknown>;
export declare const FavoritePayloadFragmentDoc: DocumentNode<FavoritePayloadFragment, unknown>;
export declare const FeedbackPayloadFragmentDoc: DocumentNode<FeedbackPayloadFragment, unknown>;
export declare const FigmaEmbedFragmentDoc: DocumentNode<FigmaEmbedFragment, unknown>;
export declare const FigmaEmbedPayloadFragmentDoc: DocumentNode<FigmaEmbedPayloadFragment, unknown>;
export declare const ImageUploadFromUrlPayloadFragmentDoc: DocumentNode<ImageUploadFromUrlPayloadFragment, unknown>;
export declare const IntegrationFragmentDoc: DocumentNode<IntegrationFragment, unknown>;
export declare const IntegrationConnectionFragmentDoc: DocumentNode<IntegrationConnectionFragment, unknown>;
export declare const IntegrationPayloadFragmentDoc: DocumentNode<IntegrationPayloadFragment, unknown>;
export declare const CommitPayloadFragmentDoc: DocumentNode<CommitPayloadFragment, unknown>;
export declare const PullRequestPayloadFragmentDoc: DocumentNode<PullRequestPayloadFragment, unknown>;
export declare const SentryIssuePayloadFragmentDoc: DocumentNode<SentryIssuePayloadFragment, unknown>;
export declare const IntegrationResourceDataFragmentDoc: DocumentNode<IntegrationResourceDataFragment, unknown>;
export declare const IntegrationResourceFragmentDoc: DocumentNode<IntegrationResourceFragment, unknown>;
export declare const IntegrationResourceConnectionFragmentDoc: DocumentNode<IntegrationResourceConnectionFragment, unknown>;
export declare const InviteDataFragmentDoc: DocumentNode<InviteDataFragment, unknown>;
export declare const InvitePagePayloadFragmentDoc: DocumentNode<InvitePagePayloadFragment, unknown>;
export declare const IssueFragmentDoc: DocumentNode<IssueFragment, unknown>;
export declare const IssueConnectionFragmentDoc: DocumentNode<IssueConnectionFragment, unknown>;
export declare const IssueHistoryFragmentDoc: DocumentNode<IssueHistoryFragment, unknown>;
export declare const IssueHistoryConnectionFragmentDoc: DocumentNode<IssueHistoryConnectionFragment, unknown>;
export declare const IssueImportFragmentDoc: DocumentNode<IssueImportFragment, unknown>;
export declare const IssueImportDeletePayloadFragmentDoc: DocumentNode<IssueImportDeletePayloadFragment, unknown>;
export declare const IssueImportPayloadFragmentDoc: DocumentNode<IssueImportPayloadFragment, unknown>;
export declare const IssueLabelFragmentDoc: DocumentNode<IssueLabelFragment, unknown>;
export declare const IssueLabelConnectionFragmentDoc: DocumentNode<IssueLabelConnectionFragment, unknown>;
export declare const IssueLabelPayloadFragmentDoc: DocumentNode<IssueLabelPayloadFragment, unknown>;
export declare const IssuePayloadFragmentDoc: DocumentNode<IssuePayloadFragment, unknown>;
export declare const IssuePriorityValueFragmentDoc: DocumentNode<IssuePriorityValueFragment, unknown>;
export declare const IssueRelationFragmentDoc: DocumentNode<IssueRelationFragment, unknown>;
export declare const IssueRelationConnectionFragmentDoc: DocumentNode<IssueRelationConnectionFragment, unknown>;
export declare const IssueRelationPayloadFragmentDoc: DocumentNode<IssueRelationPayloadFragment, unknown>;
export declare const MilestoneFragmentDoc: DocumentNode<MilestoneFragment, unknown>;
export declare const MilestoneConnectionFragmentDoc: DocumentNode<MilestoneConnectionFragment, unknown>;
export declare const MilestonePayloadFragmentDoc: DocumentNode<MilestonePayloadFragment, unknown>;
export declare const NotificationFragmentDoc: DocumentNode<NotificationFragment, unknown>;
export declare const NotificationConnectionFragmentDoc: DocumentNode<NotificationConnectionFragment, unknown>;
export declare const NotificationPayloadFragmentDoc: DocumentNode<NotificationPayloadFragment, unknown>;
export declare const NotificationSubscriptionFragmentDoc: DocumentNode<NotificationSubscriptionFragment, unknown>;
export declare const NotificationSubscriptionConnectionFragmentDoc: DocumentNode<NotificationSubscriptionConnectionFragment, unknown>;
export declare const NotificationSubscriptionPayloadFragmentDoc: DocumentNode<NotificationSubscriptionPayloadFragment, unknown>;
export declare const OauthClientFragmentDoc: DocumentNode<OauthClientFragment, unknown>;
export declare const OauthClientPayloadFragmentDoc: DocumentNode<OauthClientPayloadFragment, unknown>;
export declare const OauthTokenRevokePayloadFragmentDoc: DocumentNode<OauthTokenRevokePayloadFragment, unknown>;
export declare const OrganizationDeletePayloadFragmentDoc: DocumentNode<OrganizationDeletePayloadFragment, unknown>;
export declare const OrganizationDomainFragmentDoc: DocumentNode<OrganizationDomainFragment, unknown>;
export declare const OrganizationDomainPayloadFragmentDoc: DocumentNode<OrganizationDomainPayloadFragment, unknown>;
export declare const OrganizationDomainSimplePayloadFragmentDoc: DocumentNode<OrganizationDomainSimplePayloadFragment, unknown>;
export declare const OrganizationExistsPayloadFragmentDoc: DocumentNode<OrganizationExistsPayloadFragment, unknown>;
export declare const OrganizationInviteFragmentDoc: DocumentNode<OrganizationInviteFragment, unknown>;
export declare const OrganizationInviteConnectionFragmentDoc: DocumentNode<OrganizationInviteConnectionFragment, unknown>;
export declare const OrganizationInvitePayloadFragmentDoc: DocumentNode<OrganizationInvitePayloadFragment, unknown>;
export declare const OrganizationPayloadFragmentDoc: DocumentNode<OrganizationPayloadFragment, unknown>;
export declare const ProjectFragmentDoc: DocumentNode<ProjectFragment, unknown>;
export declare const ProjectConnectionFragmentDoc: DocumentNode<ProjectConnectionFragment, unknown>;
export declare const ProjectLinkFragmentDoc: DocumentNode<ProjectLinkFragment, unknown>;
export declare const ProjectLinkConnectionFragmentDoc: DocumentNode<ProjectLinkConnectionFragment, unknown>;
export declare const ProjectLinkPayloadFragmentDoc: DocumentNode<ProjectLinkPayloadFragment, unknown>;
export declare const ProjectPayloadFragmentDoc: DocumentNode<ProjectPayloadFragment, unknown>;
export declare const PushSubscriptionFragmentDoc: DocumentNode<PushSubscriptionFragment, unknown>;
export declare const PushSubscriptionConnectionFragmentDoc: DocumentNode<PushSubscriptionConnectionFragment, unknown>;
export declare const PushSubscriptionPayloadFragmentDoc: DocumentNode<PushSubscriptionPayloadFragment, unknown>;
export declare const ReactionFragmentDoc: DocumentNode<ReactionFragment, unknown>;
export declare const ReactionConnectionFragmentDoc: DocumentNode<ReactionConnectionFragment, unknown>;
export declare const ReactionPayloadFragmentDoc: DocumentNode<ReactionPayloadFragment, unknown>;
export declare const RotateSecretPayloadFragmentDoc: DocumentNode<RotateSecretPayloadFragment, unknown>;
export declare const SsoUrlFromEmailResponseFragmentDoc: DocumentNode<SsoUrlFromEmailResponseFragment, unknown>;
export declare const SubscriptionPayloadFragmentDoc: DocumentNode<SubscriptionPayloadFragment, unknown>;
export declare const SubscriptionSessionPayloadFragmentDoc: DocumentNode<SubscriptionSessionPayloadFragment, unknown>;
export declare const SynchronizedPayloadFragmentDoc: DocumentNode<SynchronizedPayloadFragment, unknown>;
export declare const TeamFragmentDoc: DocumentNode<TeamFragment, unknown>;
export declare const TeamConnectionFragmentDoc: DocumentNode<TeamConnectionFragment, unknown>;
export declare const TeamMembershipFragmentDoc: DocumentNode<TeamMembershipFragment, unknown>;
export declare const TeamMembershipConnectionFragmentDoc: DocumentNode<TeamMembershipConnectionFragment, unknown>;
export declare const TeamMembershipPayloadFragmentDoc: DocumentNode<TeamMembershipPayloadFragment, unknown>;
export declare const TeamPayloadFragmentDoc: DocumentNode<TeamPayloadFragment, unknown>;
export declare const TemplateConnectionFragmentDoc: DocumentNode<TemplateConnectionFragment, unknown>;
export declare const TemplatePayloadFragmentDoc: DocumentNode<TemplatePayloadFragment, unknown>;
export declare const UploadFileHeaderFragmentDoc: DocumentNode<UploadFileHeaderFragment, unknown>;
export declare const UploadFileFragmentDoc: DocumentNode<UploadFileFragment, unknown>;
export declare const UploadPayloadFragmentDoc: DocumentNode<UploadPayloadFragment, unknown>;
export declare const UserAdminPayloadFragmentDoc: DocumentNode<UserAdminPayloadFragment, unknown>;
export declare const UserConnectionFragmentDoc: DocumentNode<UserConnectionFragment, unknown>;
export declare const UserPayloadFragmentDoc: DocumentNode<UserPayloadFragment, unknown>;
export declare const UserSettingsFlagPayloadFragmentDoc: DocumentNode<UserSettingsFlagPayloadFragment, unknown>;
export declare const UserSettingsFlagsResetPayloadFragmentDoc: DocumentNode<UserSettingsFlagsResetPayloadFragment, unknown>;
export declare const UserSettingsPayloadFragmentDoc: DocumentNode<UserSettingsPayloadFragment, unknown>;
export declare const UserSubscribeToNewsletterPayloadFragmentDoc: DocumentNode<UserSubscribeToNewsletterPayloadFragment, unknown>;
export declare const ViewPreferencesFragmentDoc: DocumentNode<ViewPreferencesFragment, unknown>;
export declare const ViewPreferencesPayloadFragmentDoc: DocumentNode<ViewPreferencesPayloadFragment, unknown>;
export declare const WebhookFragmentDoc: DocumentNode<WebhookFragment, unknown>;
export declare const WebhookConnectionFragmentDoc: DocumentNode<WebhookConnectionFragment, unknown>;
export declare const WebhookPayloadFragmentDoc: DocumentNode<WebhookPayloadFragment, unknown>;
export declare const WorkflowStateFragmentDoc: DocumentNode<WorkflowStateFragment, unknown>;
export declare const WorkflowStateConnectionFragmentDoc: DocumentNode<WorkflowStateConnectionFragment, unknown>;
export declare const WorkflowStatePayloadFragmentDoc: DocumentNode<WorkflowStatePayloadFragment, unknown>;
export declare const ApiKeysDocument: DocumentNode<ApiKeysQuery, ApiKeysQueryVariables>;
export declare const ApplicationWithAuthorizationDocument: DocumentNode<ApplicationWithAuthorizationQuery, ApplicationWithAuthorizationQueryVariables>;
export declare const ArchivedModelSyncDocument: DocumentNode<ArchivedModelSyncQuery, ArchivedModelSyncQueryVariables>;
export declare const ArchivedModelsSyncDocument: DocumentNode<ArchivedModelsSyncQuery, ArchivedModelsSyncQueryVariables>;
export declare const AttachmentDocument: DocumentNode<AttachmentQuery, AttachmentQueryVariables>;
export declare const AttachmentIssueDocument: DocumentNode<AttachmentIssueQuery, AttachmentIssueQueryVariables>;
export declare const AttachmentIssue_AttachmentsDocument: DocumentNode<AttachmentIssue_AttachmentsQuery, AttachmentIssue_AttachmentsQueryVariables>;
export declare const AttachmentIssue_ChildrenDocument: DocumentNode<AttachmentIssue_ChildrenQuery, AttachmentIssue_ChildrenQueryVariables>;
export declare const AttachmentIssue_CommentsDocument: DocumentNode<AttachmentIssue_CommentsQuery, AttachmentIssue_CommentsQueryVariables>;
export declare const AttachmentIssue_HistoryDocument: DocumentNode<AttachmentIssue_HistoryQuery, AttachmentIssue_HistoryQueryVariables>;
export declare const AttachmentIssue_InverseRelationsDocument: DocumentNode<AttachmentIssue_InverseRelationsQuery, AttachmentIssue_InverseRelationsQueryVariables>;
export declare const AttachmentIssue_LabelsDocument: DocumentNode<AttachmentIssue_LabelsQuery, AttachmentIssue_LabelsQueryVariables>;
export declare const AttachmentIssue_RelationsDocument: DocumentNode<AttachmentIssue_RelationsQuery, AttachmentIssue_RelationsQueryVariables>;
export declare const AttachmentIssue_SubscribersDocument: DocumentNode<AttachmentIssue_SubscribersQuery, AttachmentIssue_SubscribersQueryVariables>;
export declare const AttachmentsDocument: DocumentNode<AttachmentsQuery, AttachmentsQueryVariables>;
export declare const AuthorizedApplicationsDocument: DocumentNode<AuthorizedApplicationsQuery, AuthorizedApplicationsQueryVariables>;
export declare const AvailableUsersDocument: DocumentNode<AvailableUsersQuery, AvailableUsersQueryVariables>;
export declare const BillingDetailsDocument: DocumentNode<BillingDetailsQuery, BillingDetailsQueryVariables>;
export declare const BillingDetails_PaymentMethodDocument: DocumentNode<BillingDetails_PaymentMethodQuery, BillingDetails_PaymentMethodQueryVariables>;
export declare const CollaborativeDocumentJoinDocument: DocumentNode<CollaborativeDocumentJoinQuery, CollaborativeDocumentJoinQueryVariables>;
export declare const CollaborativeDocumentJoin_StepsDocument: DocumentNode<CollaborativeDocumentJoin_StepsQuery, CollaborativeDocumentJoin_StepsQueryVariables>;
export declare const CommentDocument: DocumentNode<CommentQuery, CommentQueryVariables>;
export declare const CommentsDocument: DocumentNode<CommentsQuery, CommentsQueryVariables>;
export declare const CustomViewDocument: DocumentNode<CustomViewQuery, CustomViewQueryVariables>;
export declare const CustomViewsDocument: DocumentNode<CustomViewsQuery, CustomViewsQueryVariables>;
export declare const CycleDocument: DocumentNode<CycleQuery, CycleQueryVariables>;
export declare const Cycle_IssuesDocument: DocumentNode<Cycle_IssuesQuery, Cycle_IssuesQueryVariables>;
export declare const Cycle_UncompletedIssuesUponCloseDocument: DocumentNode<Cycle_UncompletedIssuesUponCloseQuery, Cycle_UncompletedIssuesUponCloseQueryVariables>;
export declare const CyclesDocument: DocumentNode<CyclesQuery, CyclesQueryVariables>;
export declare const EmojiDocument: DocumentNode<EmojiQuery, EmojiQueryVariables>;
export declare const EmojisDocument: DocumentNode<EmojisQuery, EmojisQueryVariables>;
export declare const FavoriteDocument: DocumentNode<FavoriteQuery, FavoriteQueryVariables>;
export declare const FavoritesDocument: DocumentNode<FavoritesQuery, FavoritesQueryVariables>;
export declare const FigmaEmbedInfoDocument: DocumentNode<FigmaEmbedInfoQuery, FigmaEmbedInfoQueryVariables>;
export declare const FigmaEmbedInfo_FigmaEmbedDocument: DocumentNode<FigmaEmbedInfo_FigmaEmbedQuery, FigmaEmbedInfo_FigmaEmbedQueryVariables>;
export declare const IntegrationDocument: DocumentNode<IntegrationQuery, IntegrationQueryVariables>;
export declare const IntegrationsDocument: DocumentNode<IntegrationsQuery, IntegrationsQueryVariables>;
export declare const InviteInfoDocument: DocumentNode<InviteInfoQuery, InviteInfoQueryVariables>;
export declare const InviteInfo_InviteDataDocument: DocumentNode<InviteInfo_InviteDataQuery, InviteInfo_InviteDataQueryVariables>;
export declare const IssueDocument: DocumentNode<IssueQuery, IssueQueryVariables>;
export declare const Issue_AttachmentsDocument: DocumentNode<Issue_AttachmentsQuery, Issue_AttachmentsQueryVariables>;
export declare const Issue_ChildrenDocument: DocumentNode<Issue_ChildrenQuery, Issue_ChildrenQueryVariables>;
export declare const Issue_CommentsDocument: DocumentNode<Issue_CommentsQuery, Issue_CommentsQueryVariables>;
export declare const Issue_HistoryDocument: DocumentNode<Issue_HistoryQuery, Issue_HistoryQueryVariables>;
export declare const Issue_InverseRelationsDocument: DocumentNode<Issue_InverseRelationsQuery, Issue_InverseRelationsQueryVariables>;
export declare const Issue_LabelsDocument: DocumentNode<Issue_LabelsQuery, Issue_LabelsQueryVariables>;
export declare const Issue_RelationsDocument: DocumentNode<Issue_RelationsQuery, Issue_RelationsQueryVariables>;
export declare const Issue_SubscribersDocument: DocumentNode<Issue_SubscribersQuery, Issue_SubscribersQueryVariables>;
export declare const IssueImportFinishGithubOAuthDocument: DocumentNode<IssueImportFinishGithubOAuthQuery, IssueImportFinishGithubOAuthQueryVariables>;
export declare const IssueLabelDocument: DocumentNode<IssueLabelQuery, IssueLabelQueryVariables>;
export declare const IssueLabel_IssuesDocument: DocumentNode<IssueLabel_IssuesQuery, IssueLabel_IssuesQueryVariables>;
export declare const IssueLabelsDocument: DocumentNode<IssueLabelsQuery, IssueLabelsQueryVariables>;
export declare const IssuePriorityValuesDocument: DocumentNode<IssuePriorityValuesQuery, IssuePriorityValuesQueryVariables>;
export declare const IssueRelationDocument: DocumentNode<IssueRelationQuery, IssueRelationQueryVariables>;
export declare const IssueRelationsDocument: DocumentNode<IssueRelationsQuery, IssueRelationsQueryVariables>;
export declare const IssueSearchDocument: DocumentNode<IssueSearchQuery, IssueSearchQueryVariables>;
export declare const IssuesDocument: DocumentNode<IssuesQuery, IssuesQueryVariables>;
export declare const MilestoneDocument: DocumentNode<MilestoneQuery, MilestoneQueryVariables>;
export declare const Milestone_ProjectsDocument: DocumentNode<Milestone_ProjectsQuery, Milestone_ProjectsQueryVariables>;
export declare const MilestonesDocument: DocumentNode<MilestonesQuery, MilestonesQueryVariables>;
export declare const NotificationDocument: DocumentNode<NotificationQuery, NotificationQueryVariables>;
export declare const NotificationSubscriptionDocument: DocumentNode<NotificationSubscriptionQuery, NotificationSubscriptionQueryVariables>;
export declare const NotificationSubscriptionsDocument: DocumentNode<NotificationSubscriptionsQuery, NotificationSubscriptionsQueryVariables>;
export declare const NotificationsDocument: DocumentNode<NotificationsQuery, NotificationsQueryVariables>;
export declare const OrganizationDocument: DocumentNode<OrganizationQuery, OrganizationQueryVariables>;
export declare const Organization_IntegrationsDocument: DocumentNode<Organization_IntegrationsQuery, Organization_IntegrationsQueryVariables>;
export declare const Organization_MilestonesDocument: DocumentNode<Organization_MilestonesQuery, Organization_MilestonesQueryVariables>;
export declare const Organization_TeamsDocument: DocumentNode<Organization_TeamsQuery, Organization_TeamsQueryVariables>;
export declare const Organization_UsersDocument: DocumentNode<Organization_UsersQuery, Organization_UsersQueryVariables>;
export declare const OrganizationExistsDocument: DocumentNode<OrganizationExistsQuery, OrganizationExistsQueryVariables>;
export declare const OrganizationInviteDocument: DocumentNode<OrganizationInviteQuery, OrganizationInviteQueryVariables>;
export declare const OrganizationInvite_IssuesDocument: DocumentNode<OrganizationInvite_IssuesQuery, OrganizationInvite_IssuesQueryVariables>;
export declare const OrganizationInvitesDocument: DocumentNode<OrganizationInvitesQuery, OrganizationInvitesQueryVariables>;
export declare const ProjectDocument: DocumentNode<ProjectQuery, ProjectQueryVariables>;
export declare const Project_IssuesDocument: DocumentNode<Project_IssuesQuery, Project_IssuesQueryVariables>;
export declare const Project_LinksDocument: DocumentNode<Project_LinksQuery, Project_LinksQueryVariables>;
export declare const Project_MembersDocument: DocumentNode<Project_MembersQuery, Project_MembersQueryVariables>;
export declare const Project_TeamsDocument: DocumentNode<Project_TeamsQuery, Project_TeamsQueryVariables>;
export declare const ProjectLinkDocument: DocumentNode<ProjectLinkQuery, ProjectLinkQueryVariables>;
export declare const ProjectLinksDocument: DocumentNode<ProjectLinksQuery, ProjectLinksQueryVariables>;
export declare const ProjectsDocument: DocumentNode<ProjectsQuery, ProjectsQueryVariables>;
export declare const PushSubscriptionTestDocument: DocumentNode<PushSubscriptionTestQuery, PushSubscriptionTestQueryVariables>;
export declare const ReactionDocument: DocumentNode<ReactionQuery, ReactionQueryVariables>;
export declare const ReactionsDocument: DocumentNode<ReactionsQuery, ReactionsQueryVariables>;
export declare const SsoUrlFromEmailDocument: DocumentNode<SsoUrlFromEmailQuery, SsoUrlFromEmailQueryVariables>;
export declare const SubscriptionDocument: DocumentNode<SubscriptionQuery, SubscriptionQueryVariables>;
export declare const SyncBootstrapDocument: DocumentNode<SyncBootstrapQuery, SyncBootstrapQueryVariables>;
export declare const TeamDocument: DocumentNode<TeamQuery, TeamQueryVariables>;
export declare const Team_CyclesDocument: DocumentNode<Team_CyclesQuery, Team_CyclesQueryVariables>;
export declare const Team_IssuesDocument: DocumentNode<Team_IssuesQuery, Team_IssuesQueryVariables>;
export declare const Team_LabelsDocument: DocumentNode<Team_LabelsQuery, Team_LabelsQueryVariables>;
export declare const Team_MembersDocument: DocumentNode<Team_MembersQuery, Team_MembersQueryVariables>;
export declare const Team_MembershipsDocument: DocumentNode<Team_MembershipsQuery, Team_MembershipsQueryVariables>;
export declare const Team_ProjectsDocument: DocumentNode<Team_ProjectsQuery, Team_ProjectsQueryVariables>;
export declare const Team_StatesDocument: DocumentNode<Team_StatesQuery, Team_StatesQueryVariables>;
export declare const Team_TemplatesDocument: DocumentNode<Team_TemplatesQuery, Team_TemplatesQueryVariables>;
export declare const Team_WebhooksDocument: DocumentNode<Team_WebhooksQuery, Team_WebhooksQueryVariables>;
export declare const TeamMembershipDocument: DocumentNode<TeamMembershipQuery, TeamMembershipQueryVariables>;
export declare const TeamMembershipsDocument: DocumentNode<TeamMembershipsQuery, TeamMembershipsQueryVariables>;
export declare const TeamsDocument: DocumentNode<TeamsQuery, TeamsQueryVariables>;
export declare const TemplateDocument: DocumentNode<TemplateQuery, TemplateQueryVariables>;
export declare const TemplatesDocument: DocumentNode<TemplatesQuery, TemplatesQueryVariables>;
export declare const UserDocument: DocumentNode<UserQuery, UserQueryVariables>;
export declare const User_AssignedIssuesDocument: DocumentNode<User_AssignedIssuesQuery, User_AssignedIssuesQueryVariables>;
export declare const User_CreatedIssuesDocument: DocumentNode<User_CreatedIssuesQuery, User_CreatedIssuesQueryVariables>;
export declare const User_TeamMembershipsDocument: DocumentNode<User_TeamMembershipsQuery, User_TeamMembershipsQueryVariables>;
export declare const User_TeamsDocument: DocumentNode<User_TeamsQuery, User_TeamsQueryVariables>;
export declare const UserSettingsDocument: DocumentNode<UserSettingsQuery, UserSettingsQueryVariables>;
export declare const UsersDocument: DocumentNode<UsersQuery, UsersQueryVariables>;
export declare const ViewerDocument: DocumentNode<ViewerQuery, ViewerQueryVariables>;
export declare const Viewer_AssignedIssuesDocument: DocumentNode<Viewer_AssignedIssuesQuery, Viewer_AssignedIssuesQueryVariables>;
export declare const Viewer_CreatedIssuesDocument: DocumentNode<Viewer_CreatedIssuesQuery, Viewer_CreatedIssuesQueryVariables>;
export declare const Viewer_TeamMembershipsDocument: DocumentNode<Viewer_TeamMembershipsQuery, Viewer_TeamMembershipsQueryVariables>;
export declare const Viewer_TeamsDocument: DocumentNode<Viewer_TeamsQuery, Viewer_TeamsQueryVariables>;
export declare const WebhookDocument: DocumentNode<WebhookQuery, WebhookQueryVariables>;
export declare const WebhooksDocument: DocumentNode<WebhooksQuery, WebhooksQueryVariables>;
export declare const WorkflowStateDocument: DocumentNode<WorkflowStateQuery, WorkflowStateQueryVariables>;
export declare const WorkflowState_IssuesDocument: DocumentNode<WorkflowState_IssuesQuery, WorkflowState_IssuesQueryVariables>;
export declare const WorkflowStatesDocument: DocumentNode<WorkflowStatesQuery, WorkflowStatesQueryVariables>;
export declare const ApiKeyCreateDocument: DocumentNode<ApiKeyCreateMutation, ApiKeyCreateMutationVariables>;
export declare const ApiKeyDeleteDocument: DocumentNode<ApiKeyDeleteMutation, ApiKeyDeleteMutationVariables>;
export declare const AttachmentArchiveDocument: DocumentNode<AttachmentArchiveMutation, AttachmentArchiveMutationVariables>;
export declare const AttachmentCreateDocument: DocumentNode<AttachmentCreateMutation, AttachmentCreateMutationVariables>;
export declare const AttachmentUpdateDocument: DocumentNode<AttachmentUpdateMutation, AttachmentUpdateMutationVariables>;
export declare const BillingEmailUpdateDocument: DocumentNode<BillingEmailUpdateMutation, BillingEmailUpdateMutationVariables>;
export declare const CollaborativeDocumentUpdateDocument: DocumentNode<CollaborativeDocumentUpdateMutation, CollaborativeDocumentUpdateMutationVariables>;
export declare const CommentCreateDocument: DocumentNode<CommentCreateMutation, CommentCreateMutationVariables>;
export declare const CommentDeleteDocument: DocumentNode<CommentDeleteMutation, CommentDeleteMutationVariables>;
export declare const CommentUpdateDocument: DocumentNode<CommentUpdateMutation, CommentUpdateMutationVariables>;
export declare const ContactCreateDocument: DocumentNode<ContactCreateMutation, ContactCreateMutationVariables>;
export declare const CreateCsvExportReportDocument: DocumentNode<CreateCsvExportReportMutation, CreateCsvExportReportMutationVariables>;
export declare const CreateOrganizationFromOnboardingDocument: DocumentNode<CreateOrganizationFromOnboardingMutation, CreateOrganizationFromOnboardingMutationVariables>;
export declare const CustomViewCreateDocument: DocumentNode<CustomViewCreateMutation, CustomViewCreateMutationVariables>;
export declare const CustomViewDeleteDocument: DocumentNode<CustomViewDeleteMutation, CustomViewDeleteMutationVariables>;
export declare const CustomViewUpdateDocument: DocumentNode<CustomViewUpdateMutation, CustomViewUpdateMutationVariables>;
export declare const CycleArchiveDocument: DocumentNode<CycleArchiveMutation, CycleArchiveMutationVariables>;
export declare const CycleCreateDocument: DocumentNode<CycleCreateMutation, CycleCreateMutationVariables>;
export declare const CycleUpdateDocument: DocumentNode<CycleUpdateMutation, CycleUpdateMutationVariables>;
export declare const DebugCreateSamlOrgDocument: DocumentNode<DebugCreateSamlOrgMutation, DebugCreateSamlOrgMutationVariables>;
export declare const DebugFailWithInternalErrorDocument: DocumentNode<DebugFailWithInternalErrorMutation, DebugFailWithInternalErrorMutationVariables>;
export declare const DebugFailWithWarningDocument: DocumentNode<DebugFailWithWarningMutation, DebugFailWithWarningMutationVariables>;
export declare const EmailTokenUserAccountAuthDocument: DocumentNode<EmailTokenUserAccountAuthMutation, EmailTokenUserAccountAuthMutationVariables>;
export declare const EmailUnsubscribeDocument: DocumentNode<EmailUnsubscribeMutation, EmailUnsubscribeMutationVariables>;
export declare const EmailUserAccountAuthChallengeDocument: DocumentNode<EmailUserAccountAuthChallengeMutation, EmailUserAccountAuthChallengeMutationVariables>;
export declare const EmojiCreateDocument: DocumentNode<EmojiCreateMutation, EmojiCreateMutationVariables>;
export declare const EmojiDeleteDocument: DocumentNode<EmojiDeleteMutation, EmojiDeleteMutationVariables>;
export declare const EventCreateDocument: DocumentNode<EventCreateMutation, EventCreateMutationVariables>;
export declare const FavoriteCreateDocument: DocumentNode<FavoriteCreateMutation, FavoriteCreateMutationVariables>;
export declare const FavoriteDeleteDocument: DocumentNode<FavoriteDeleteMutation, FavoriteDeleteMutationVariables>;
export declare const FavoriteUpdateDocument: DocumentNode<FavoriteUpdateMutation, FavoriteUpdateMutationVariables>;
export declare const FeedbackCreateDocument: DocumentNode<FeedbackCreateMutation, FeedbackCreateMutationVariables>;
export declare const FileUploadDocument: DocumentNode<FileUploadMutation, FileUploadMutationVariables>;
export declare const GoogleUserAccountAuthDocument: DocumentNode<GoogleUserAccountAuthMutation, GoogleUserAccountAuthMutationVariables>;
export declare const ImageUploadFromUrlDocument: DocumentNode<ImageUploadFromUrlMutation, ImageUploadFromUrlMutationVariables>;
export declare const IntegrationDeleteDocument: DocumentNode<IntegrationDeleteMutation, IntegrationDeleteMutationVariables>;
export declare const IntegrationFigmaDocument: DocumentNode<IntegrationFigmaMutation, IntegrationFigmaMutationVariables>;
export declare const IntegrationGithubConnectDocument: DocumentNode<IntegrationGithubConnectMutation, IntegrationGithubConnectMutationVariables>;
export declare const IntegrationGitlabConnectDocument: DocumentNode<IntegrationGitlabConnectMutation, IntegrationGitlabConnectMutationVariables>;
export declare const IntegrationGoogleSheetsDocument: DocumentNode<IntegrationGoogleSheetsMutation, IntegrationGoogleSheetsMutationVariables>;
export declare const IntegrationResourceArchiveDocument: DocumentNode<IntegrationResourceArchiveMutation, IntegrationResourceArchiveMutationVariables>;
export declare const IntegrationSentryConnectDocument: DocumentNode<IntegrationSentryConnectMutation, IntegrationSentryConnectMutationVariables>;
export declare const IntegrationSlackDocument: DocumentNode<IntegrationSlackMutation, IntegrationSlackMutationVariables>;
export declare const IntegrationSlackImportEmojisDocument: DocumentNode<IntegrationSlackImportEmojisMutation, IntegrationSlackImportEmojisMutationVariables>;
export declare const IntegrationSlackPersonalDocument: DocumentNode<IntegrationSlackPersonalMutation, IntegrationSlackPersonalMutationVariables>;
export declare const IntegrationSlackPostDocument: DocumentNode<IntegrationSlackPostMutation, IntegrationSlackPostMutationVariables>;
export declare const IntegrationSlackProjectPostDocument: DocumentNode<IntegrationSlackProjectPostMutation, IntegrationSlackProjectPostMutationVariables>;
export declare const IntegrationZendeskDocument: DocumentNode<IntegrationZendeskMutation, IntegrationZendeskMutationVariables>;
export declare const IssueArchiveDocument: DocumentNode<IssueArchiveMutation, IssueArchiveMutationVariables>;
export declare const IssueCreateDocument: DocumentNode<IssueCreateMutation, IssueCreateMutationVariables>;
export declare const IssueImportCreateAsanaDocument: DocumentNode<IssueImportCreateAsanaMutation, IssueImportCreateAsanaMutationVariables>;
export declare const IssueImportCreateClubhouseDocument: DocumentNode<IssueImportCreateClubhouseMutation, IssueImportCreateClubhouseMutationVariables>;
export declare const IssueImportCreateGithubDocument: DocumentNode<IssueImportCreateGithubMutation, IssueImportCreateGithubMutationVariables>;
export declare const IssueImportCreateJiraDocument: DocumentNode<IssueImportCreateJiraMutation, IssueImportCreateJiraMutationVariables>;
export declare const IssueImportDeleteDocument: DocumentNode<IssueImportDeleteMutation, IssueImportDeleteMutationVariables>;
export declare const IssueLabelArchiveDocument: DocumentNode<IssueLabelArchiveMutation, IssueLabelArchiveMutationVariables>;
export declare const IssueLabelCreateDocument: DocumentNode<IssueLabelCreateMutation, IssueLabelCreateMutationVariables>;
export declare const IssueLabelUpdateDocument: DocumentNode<IssueLabelUpdateMutation, IssueLabelUpdateMutationVariables>;
export declare const IssueRelationCreateDocument: DocumentNode<IssueRelationCreateMutation, IssueRelationCreateMutationVariables>;
export declare const IssueRelationDeleteDocument: DocumentNode<IssueRelationDeleteMutation, IssueRelationDeleteMutationVariables>;
export declare const IssueRelationUpdateDocument: DocumentNode<IssueRelationUpdateMutation, IssueRelationUpdateMutationVariables>;
export declare const IssueUnarchiveDocument: DocumentNode<IssueUnarchiveMutation, IssueUnarchiveMutationVariables>;
export declare const IssueUpdateDocument: DocumentNode<IssueUpdateMutation, IssueUpdateMutationVariables>;
export declare const JoinOrganizationFromOnboardingDocument: DocumentNode<JoinOrganizationFromOnboardingMutation, JoinOrganizationFromOnboardingMutationVariables>;
export declare const LeaveOrganizationDocument: DocumentNode<LeaveOrganizationMutation, LeaveOrganizationMutationVariables>;
export declare const MilestoneCreateDocument: DocumentNode<MilestoneCreateMutation, MilestoneCreateMutationVariables>;
export declare const MilestoneDeleteDocument: DocumentNode<MilestoneDeleteMutation, MilestoneDeleteMutationVariables>;
export declare const MilestoneUpdateDocument: DocumentNode<MilestoneUpdateMutation, MilestoneUpdateMutationVariables>;
export declare const NotificationArchiveDocument: DocumentNode<NotificationArchiveMutation, NotificationArchiveMutationVariables>;
export declare const NotificationCreateDocument: DocumentNode<NotificationCreateMutation, NotificationCreateMutationVariables>;
export declare const NotificationDeleteDocument: DocumentNode<NotificationDeleteMutation, NotificationDeleteMutationVariables>;
export declare const NotificationSubscriptionCreateDocument: DocumentNode<NotificationSubscriptionCreateMutation, NotificationSubscriptionCreateMutationVariables>;
export declare const NotificationSubscriptionDeleteDocument: DocumentNode<NotificationSubscriptionDeleteMutation, NotificationSubscriptionDeleteMutationVariables>;
export declare const NotificationUnarchiveDocument: DocumentNode<NotificationUnarchiveMutation, NotificationUnarchiveMutationVariables>;
export declare const NotificationUpdateDocument: DocumentNode<NotificationUpdateMutation, NotificationUpdateMutationVariables>;
export declare const OauthClientArchiveDocument: DocumentNode<OauthClientArchiveMutation, OauthClientArchiveMutationVariables>;
export declare const OauthClientCreateDocument: DocumentNode<OauthClientCreateMutation, OauthClientCreateMutationVariables>;
export declare const OauthClientRotateSecretDocument: DocumentNode<OauthClientRotateSecretMutation, OauthClientRotateSecretMutationVariables>;
export declare const OauthClientUpdateDocument: DocumentNode<OauthClientUpdateMutation, OauthClientUpdateMutationVariables>;
export declare const OauthTokenRevokeDocument: DocumentNode<OauthTokenRevokeMutation, OauthTokenRevokeMutationVariables>;
export declare const OrganizationDeleteDocument: DocumentNode<OrganizationDeleteMutation, OrganizationDeleteMutationVariables>;
export declare const OrganizationDeleteChallengeDocument: DocumentNode<OrganizationDeleteChallengeMutation, OrganizationDeleteChallengeMutationVariables>;
export declare const OrganizationDomainCreateDocument: DocumentNode<OrganizationDomainCreateMutation, OrganizationDomainCreateMutationVariables>;
export declare const OrganizationDomainDeleteDocument: DocumentNode<OrganizationDomainDeleteMutation, OrganizationDomainDeleteMutationVariables>;
export declare const OrganizationDomainVerifyDocument: DocumentNode<OrganizationDomainVerifyMutation, OrganizationDomainVerifyMutationVariables>;
export declare const OrganizationInviteCreateDocument: DocumentNode<OrganizationInviteCreateMutation, OrganizationInviteCreateMutationVariables>;
export declare const OrganizationInviteDeleteDocument: DocumentNode<OrganizationInviteDeleteMutation, OrganizationInviteDeleteMutationVariables>;
export declare const OrganizationUpdateDocument: DocumentNode<OrganizationUpdateMutation, OrganizationUpdateMutationVariables>;
export declare const ProjectArchiveDocument: DocumentNode<ProjectArchiveMutation, ProjectArchiveMutationVariables>;
export declare const ProjectCreateDocument: DocumentNode<ProjectCreateMutation, ProjectCreateMutationVariables>;
export declare const ProjectLinkCreateDocument: DocumentNode<ProjectLinkCreateMutation, ProjectLinkCreateMutationVariables>;
export declare const ProjectLinkDeleteDocument: DocumentNode<ProjectLinkDeleteMutation, ProjectLinkDeleteMutationVariables>;
export declare const ProjectUpdateDocument: DocumentNode<ProjectUpdateMutation, ProjectUpdateMutationVariables>;
export declare const PushSubscriptionCreateDocument: DocumentNode<PushSubscriptionCreateMutation, PushSubscriptionCreateMutationVariables>;
export declare const PushSubscriptionDeleteDocument: DocumentNode<PushSubscriptionDeleteMutation, PushSubscriptionDeleteMutationVariables>;
export declare const ReactionCreateDocument: DocumentNode<ReactionCreateMutation, ReactionCreateMutationVariables>;
export declare const ReactionDeleteDocument: DocumentNode<ReactionDeleteMutation, ReactionDeleteMutationVariables>;
export declare const RefreshGoogleSheetsDataDocument: DocumentNode<RefreshGoogleSheetsDataMutation, RefreshGoogleSheetsDataMutationVariables>;
export declare const ResentOrganizationInviteDocument: DocumentNode<ResentOrganizationInviteMutation, ResentOrganizationInviteMutationVariables>;
export declare const SamlTokenUserAccountAuthDocument: DocumentNode<SamlTokenUserAccountAuthMutation, SamlTokenUserAccountAuthMutationVariables>;
export declare const SubscriptionArchiveDocument: DocumentNode<SubscriptionArchiveMutation, SubscriptionArchiveMutationVariables>;
export declare const SubscriptionSessionCreateDocument: DocumentNode<SubscriptionSessionCreateMutation, SubscriptionSessionCreateMutationVariables>;
export declare const SubscriptionUpdateDocument: DocumentNode<SubscriptionUpdateMutation, SubscriptionUpdateMutationVariables>;
export declare const SubscriptionUpdateSessionCreateDocument: DocumentNode<SubscriptionUpdateSessionCreateMutation, SubscriptionUpdateSessionCreateMutationVariables>;
export declare const SubscriptionUpgradeDocument: DocumentNode<SubscriptionUpgradeMutation, SubscriptionUpgradeMutationVariables>;
export declare const TeamArchiveDocument: DocumentNode<TeamArchiveMutation, TeamArchiveMutationVariables>;
export declare const TeamCreateDocument: DocumentNode<TeamCreateMutation, TeamCreateMutationVariables>;
export declare const TeamDeleteDocument: DocumentNode<TeamDeleteMutation, TeamDeleteMutationVariables>;
export declare const TeamMembershipCreateDocument: DocumentNode<TeamMembershipCreateMutation, TeamMembershipCreateMutationVariables>;
export declare const TeamMembershipDeleteDocument: DocumentNode<TeamMembershipDeleteMutation, TeamMembershipDeleteMutationVariables>;
export declare const TeamMembershipUpdateDocument: DocumentNode<TeamMembershipUpdateMutation, TeamMembershipUpdateMutationVariables>;
export declare const TeamUpdateDocument: DocumentNode<TeamUpdateMutation, TeamUpdateMutationVariables>;
export declare const TemplateCreateDocument: DocumentNode<TemplateCreateMutation, TemplateCreateMutationVariables>;
export declare const TemplateDeleteDocument: DocumentNode<TemplateDeleteMutation, TemplateDeleteMutationVariables>;
export declare const TemplateUpdateDocument: DocumentNode<TemplateUpdateMutation, TemplateUpdateMutationVariables>;
export declare const UserDemoteAdminDocument: DocumentNode<UserDemoteAdminMutation, UserDemoteAdminMutationVariables>;
export declare const UserFlagUpdateDocument: DocumentNode<UserFlagUpdateMutation, UserFlagUpdateMutationVariables>;
export declare const UserPromoteAdminDocument: DocumentNode<UserPromoteAdminMutation, UserPromoteAdminMutationVariables>;
export declare const UserSettingsFlagIncrementDocument: DocumentNode<UserSettingsFlagIncrementMutation, UserSettingsFlagIncrementMutationVariables>;
export declare const UserSettingsFlagsResetDocument: DocumentNode<UserSettingsFlagsResetMutation, UserSettingsFlagsResetMutationVariables>;
export declare const UserSettingsUpdateDocument: DocumentNode<UserSettingsUpdateMutation, UserSettingsUpdateMutationVariables>;
export declare const UserSubscribeToNewsletterDocument: DocumentNode<UserSubscribeToNewsletterMutation, UserSubscribeToNewsletterMutationVariables>;
export declare const UserSuspendDocument: DocumentNode<UserSuspendMutation, UserSuspendMutationVariables>;
export declare const UserUnsuspendDocument: DocumentNode<UserUnsuspendMutation, UserUnsuspendMutationVariables>;
export declare const UserUpdateDocument: DocumentNode<UserUpdateMutation, UserUpdateMutationVariables>;
export declare const ViewPreferencesCreateDocument: DocumentNode<ViewPreferencesCreateMutation, ViewPreferencesCreateMutationVariables>;
export declare const ViewPreferencesDeleteDocument: DocumentNode<ViewPreferencesDeleteMutation, ViewPreferencesDeleteMutationVariables>;
export declare const ViewPreferencesUpdateDocument: DocumentNode<ViewPreferencesUpdateMutation, ViewPreferencesUpdateMutationVariables>;
export declare const WebhookCreateDocument: DocumentNode<WebhookCreateMutation, WebhookCreateMutationVariables>;
export declare const WebhookDeleteDocument: DocumentNode<WebhookDeleteMutation, WebhookDeleteMutationVariables>;
export declare const WebhookUpdateDocument: DocumentNode<WebhookUpdateMutation, WebhookUpdateMutationVariables>;
export declare const WorkflowStateArchiveDocument: DocumentNode<WorkflowStateArchiveMutation, WorkflowStateArchiveMutationVariables>;
export declare const WorkflowStateCreateDocument: DocumentNode<WorkflowStateCreateMutation, WorkflowStateCreateMutationVariables>;
export declare const WorkflowStateUpdateDocument: DocumentNode<WorkflowStateUpdateMutation, WorkflowStateUpdateMutationVariables>;
//# sourceMappingURL=_generated_documents.d.ts.map